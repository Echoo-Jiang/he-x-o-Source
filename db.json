{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/images/hello.png","path":"images/hello.png","modified":0,"renderable":0},{"_id":"themes/particlex/source/css/main.css","path":"css/main.css","modified":0,"renderable":1},{"_id":"themes/particlex/source/images/1.jpg","path":"images/1.jpg","modified":0,"renderable":1},{"_id":"themes/particlex/source/images/3.png","path":"images/3.png","modified":0,"renderable":1},{"_id":"themes/particlex/source/images/2.jpg","path":"images/2.jpg","modified":0,"renderable":1},{"_id":"themes/particlex/source/images/4.jpg","path":"images/4.jpg","modified":0,"renderable":1},{"_id":"themes/particlex/source/images/5.jpg","path":"images/5.jpg","modified":0,"renderable":1},{"_id":"themes/particlex/source/images/6.jpg","path":"images/6.jpg","modified":0,"renderable":1},{"_id":"themes/particlex/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/particlex/source/js/background.min.js","path":"js/background.min.js","modified":0,"renderable":1},{"_id":"themes/particlex/source/images/background.png","path":"images/background.png","modified":0,"renderable":1},{"_id":"themes/particlex/source/images/loading2.gif","path":"images/loading2.gif","modified":0,"renderable":1},{"_id":"themes/particlex/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/particlex/source/js/fireworks.js","path":"js/fireworks.js","modified":0,"renderable":1},{"_id":"themes/particlex/source/js/fireworks.min.js","path":"js/fireworks.min.js","modified":0,"renderable":1},{"_id":"themes/particlex/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/particlex/source/musics/index.md","path":"musics/index.md","modified":0,"renderable":1},{"_id":"themes/particlex/source/dist/APlayer.min.css","path":"dist/APlayer.min.css","modified":0,"renderable":1},{"_id":"themes/particlex/source/dist/APlayer.min.css.map","path":"dist/APlayer.min.css.map","modified":0,"renderable":1},{"_id":"themes/particlex/source/dist/APlayer.min.js","path":"dist/APlayer.min.js","modified":0,"renderable":1},{"_id":"themes/particlex/source/dist/APlayer.min.js.map","path":"dist/APlayer.min.js.map","modified":0,"renderable":1},{"_id":"themes/particlex/source/dist/music.js","path":"dist/music.js","modified":0,"renderable":1},{"_id":"themes/particlex/source/js/lib/crypto.js","path":"js/lib/crypto.js","modified":0,"renderable":1},{"_id":"themes/particlex/source/js/lib/highlight.js","path":"js/lib/highlight.js","modified":0,"renderable":1},{"_id":"themes/particlex/source/js/lib/home.js","path":"js/lib/home.js","modified":0,"renderable":1},{"_id":"themes/particlex/source/js/lib/math.js","path":"js/lib/math.js","modified":0,"renderable":1},{"_id":"themes/particlex/source/js/lib/preview.js","path":"js/lib/preview.js","modified":0,"renderable":1},{"_id":"themes/particlex/source/js/lib/search.js","path":"js/lib/search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/Hello-World-1.md","hash":"5c3b4ed64da34025dbd65526716826fde8d6c58c","modified":1698124158879},{"_id":"source/_posts/Markdown语法简介.md","hash":"5a742150d5f6041dd21b63ee3a1f42305b98bec3","modified":1698075592647},{"_id":"source/_posts/OLED和LCD屏幕的区别.md","hash":"937d0142d7189daf4a79ecd63d24a420094bf837","modified":1697543381182},{"_id":"source/_posts/网络服务器软件测试开发技术.md","hash":"460bbdab94b6295273b8998aede1183826b1eb6b","modified":1698075511023},{"_id":"source/categories/index.md","hash":"53c29e6d4399a71c617571a1e702155eddb1cd30","modified":1697525597346},{"_id":"source/musics/index.md","hash":"3bc2c8b5533edacd76b346e00b5f0af804a809d0","modified":1698123371685},{"_id":"source/tags/index.md","hash":"d6576d6e128e4e503e93f8700bb2836e92f1c8be","modified":1697524766986},{"_id":"source/about/index.md","hash":"6174819b308f22542a388ce17d4e9cee949d2cf8","modified":1697523066756},{"_id":"themes/particlex/.gitignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1697475486819},{"_id":"themes/particlex/.npmignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1697475486819},{"_id":"themes/particlex/_config.yml","hash":"aad683ece1856b92a76b232156f0928e3e2cfe67","modified":1698123325738},{"_id":"themes/particlex/package.json","hash":"87e07c526f7f7dbfcf83210cb9602171e12ef278","modified":1697475486827},{"_id":"themes/particlex/README.md","hash":"630c132c1a8ffea49fad7cb5f9a0a4fd9167453b","modified":1697475486820},{"_id":"themes/particlex/.github/dependabot.yml","hash":"d2adc8df9ae7f28520d2fd5c0579e75dbe352bdc","modified":1697475486818},{"_id":"themes/particlex/layout/_layout.njk","hash":"0aaa571333a0ffcfb9c9339c01d227839db900ab","modified":1698117544542},{"_id":"themes/particlex/layout/archives.ejs","hash":"e88cc2bdd904eb7b33acf1c8eb7602a75ecfe0b7","modified":1697475486821},{"_id":"themes/particlex/layout/card.ejs","hash":"785040262518ba3d0c02127d08b796a18321e75e","modified":1698679879032},{"_id":"themes/particlex/layout/categories.ejs","hash":"5a2a806deeb716a7c97be43155c3febca77a4e88","modified":1697475486822},{"_id":"themes/particlex/LICENSE","hash":"c42335f46096b2ec5509087ab122e5dfd43e2cf4","modified":1697475486820},{"_id":"themes/particlex/layout/comment.ejs","hash":"267809e50962af7ab6bc5892855f765d754a62e4","modified":1697475486823},{"_id":"themes/particlex/layout/current.ejs","hash":"adbe23a88b0e3b19084d9d957821ea28d9884416","modified":1697475486823},{"_id":"themes/particlex/layout/footer.ejs","hash":"357b2db2eab031150e06dd47695dc9916d875fc4","modified":1697475486824},{"_id":"themes/particlex/layout/import.ejs","hash":"e9c33d850d4abecec31c2793c01ca7d1ef92803b","modified":1697475486824},{"_id":"themes/particlex/layout/menu.ejs","hash":"1c78bd05cdfb3ae7a47ed572229a1970335fe8b8","modified":1697475486825},{"_id":"themes/particlex/layout/index.ejs","hash":"3665c29a2fb7ec6671ecce946860a573fa95f59c","modified":1697475486825},{"_id":"themes/particlex/pnpm-lock.yaml","hash":"845a5052655bb18c485feaa1cd983f2ff3fac5c1","modified":1697475486828},{"_id":"themes/particlex/layout/layout.ejs","hash":"cfbaddc8293945849f95dcba57108e78982dd312","modified":1698123277557},{"_id":"themes/particlex/layout/post.ejs","hash":"f532ed1cc4b492ff972b8c442b3e369c579090af","modified":1697475486826},{"_id":"themes/particlex/layout/musics.ejs","hash":"6576417c05bef21489ee934f4869f510351ce6c5","modified":1698123409513},{"_id":"themes/particlex/source/css/main.css","hash":"ff49d90e3eb12de20b68a95c028a44d8d5f28a2e","modified":1697475486829},{"_id":"themes/particlex/layout/posts.ejs","hash":"6afa1f8bdf5c8e95e9fa60ac75297ef7dd06c1af","modified":1697475486826},{"_id":"themes/particlex/layout/tags.ejs","hash":"4ab01a789f62ea7a6b8d3187385d0a9b8a06e3fb","modified":1697475486827},{"_id":"themes/particlex/source/js/background.min.js","hash":"0b75485c0e7e4c1c00728408b814900ba5103def","modified":1698120263398},{"_id":"themes/particlex/source/js/fireworks.js","hash":"3f948d2e729c2b7455447271fe59e890e4ba28b5","modified":1698117480673},{"_id":"themes/particlex/source/js/fireworks.min.js","hash":"6f5ccef48af055cb6f4419b6b6d5990678cb502c","modified":1698119598065},{"_id":"themes/particlex/source/js/main.js","hash":"420d9ab7f2e0cb44bdc5335389344ec1e7253db5","modified":1697475486842},{"_id":"themes/particlex/source/dist/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1698114598095},{"_id":"themes/particlex/source/dist/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1698114598099},{"_id":"themes/particlex/source/musics/index.md","hash":"3bc2c8b5533edacd76b346e00b5f0af804a809d0","modified":1698123371685},{"_id":"themes/particlex/source/dist/APlayer.min.css.map","hash":"c59d2bc9472922cf6ef9a99e052dbee6cc7e6b36","modified":1698114598105},{"_id":"themes/particlex/source/dist/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1698114599103},{"_id":"themes/particlex/source/dist/music.js","hash":"88e2e2f06b56d0b6f002ef587459b78694870e9b","modified":1698122353732},{"_id":"themes/particlex/source/js/lib/highlight.js","hash":"5db15728bb94715c2078a5ed4cc46abc0ad792c4","modified":1697475486840},{"_id":"themes/particlex/source/js/lib/home.js","hash":"5ec113e1d72efaab5eb31addc05eb9dcf26ce1af","modified":1697475486840},{"_id":"themes/particlex/source/images/loading.gif","hash":"9c840c5c3e7b97a184deb390df2f6926d6161708","modified":1697475486839},{"_id":"themes/particlex/source/js/lib/preview.js","hash":"d3050c6ed6d52e451cc1810843c5d595eadb8e5a","modified":1697475486842},{"_id":"themes/particlex/source/js/lib/crypto.js","hash":"3db8692ac636d9f72dc94127216d21f9793e6602","modified":1697475486840},{"_id":"themes/particlex/source/js/lib/math.js","hash":"f7716e83ef236818239fcae91defe730d5bfbc6d","modified":1697475486841},{"_id":"themes/particlex/source/js/lib/search.js","hash":"d507facc680300c046f2b967279959541313e1f9","modified":1697475486842},{"_id":"themes/particlex/source/dist/APlayer.min.js.map","hash":"31a19da0f0cb6b00ec212eafa847f31af86788df","modified":1698114600820},{"_id":"themes/particlex/source/images/5.jpg","hash":"38ca90744828d44fd85fb8c3867dcb2d23b060d2","modified":1697476492635},{"_id":"themes/particlex/source/images/loading2.gif","hash":"526f25dedd49aebc4c1851c639c51818e16b65ed","modified":1697512015908},{"_id":"themes/particlex/source/images/avatar.jpg","hash":"cd5b921252d1a4f15e17858f4f816ba768a6acf7","modified":1697475486832},{"_id":"themes/particlex/source/images/4.jpg","hash":"d2da2f7cf6db15b06d7215ec91d6eaeef1dfae15","modified":1695400920851},{"_id":"themes/particlex/source/images/6.jpg","hash":"d4cd5b1193bcf15f9420ee92a321ab62b5b8c452","modified":1697475486838},{"_id":"themes/particlex/source/images/1.jpg","hash":"b36e0043c3166dbe84a2ec5aee6893f4ce88db58","modified":1697476151348},{"_id":"themes/particlex/source/images/2.jpg","hash":"89dfb6a3957e6c19e04a21ae180d354fdcd4a58f","modified":1697476221963},{"_id":"source/images/hello.png","hash":"e86689cc67b2299de0db966032ff348853970458","modified":1697528473326},{"_id":"themes/particlex/source/images/background.png","hash":"13cb9dc559e65a8ee4fa4b2b7bee22ef741c078b","modified":1623265905212},{"_id":"themes/particlex/source/images/3.png","hash":"8e2f57697681ae9affc4f6bc2227b6df8f2e65e0","modified":1697477007330},{"_id":"public/musics/index.html","hash":"736f2676e8310f729d00f486948151e59e802e21","modified":1698125810687},{"_id":"public/about/index.html","hash":"0a1b0f7feb6b96f737223331fc0c3296eeca073d","modified":1698125810687},{"_id":"public/categories/index.html","hash":"19cf26444c34c257eea5284963d59292c215b00a","modified":1698843010139},{"_id":"public/tags/index.html","hash":"bda8338d0d14c9c1040d026b4b66bcfa27579192","modified":1698843010139},{"_id":"public/2023/10/20/网络服务器软件测试开发技术/index.html","hash":"a05febc1eb20d9d3803a60740c44fa133bdbf773","modified":1698843010139},{"_id":"public/2023/10/17/OLED和LCD屏幕的区别/index.html","hash":"06cf20cb6e082aeb6850c914b77d03c222bb917c","modified":1698843010139},{"_id":"public/2023/07/27/Hello-World-1/index.html","hash":"0c94ec5b9f424c45ecbdad8b6a479ec6fc68e562","modified":1698843010139},{"_id":"public/2023/06/23/Markdown语法简介/index.html","hash":"45759a8fcac417046ff1293176e3bffb47a64635","modified":1698843010139},{"_id":"public/archives/index.html","hash":"62c2429e53617321e1c6f0cdf0a336094e719dc0","modified":1698843010139},{"_id":"public/archives/2023/index.html","hash":"bc7147b511d8ac9ff4ed20465d20ac5775221c5b","modified":1698843010139},{"_id":"public/archives/2023/06/index.html","hash":"10cd7a31643a34f8be9d1b3d5b835431a96c5c3f","modified":1698843010139},{"_id":"public/archives/2023/07/index.html","hash":"6bb5df7b1bc02a4cc565f8b50a28ba20c2dbe40e","modified":1698843010139},{"_id":"public/archives/2023/10/index.html","hash":"38402d8dc3ad7639dc4870851db853bfb11e42af","modified":1698843010139},{"_id":"public/categories/杂谈/index.html","hash":"cbd286d6744be2a47a3aac6cfe0ece0c31598f5b","modified":1698843010139},{"_id":"public/categories/编辑器/index.html","hash":"5e5c926809bb808cb0fe5074ec732c39bb3d5699","modified":1698843010139},{"_id":"public/categories/元器件/index.html","hash":"0f44fa53bb8917e54a81d711507cd86c6ce3e245","modified":1698843010139},{"_id":"public/categories/网络协议/index.html","hash":"5a7f22292240b3e16547e18b03e5b8f6f5731439","modified":1698843010139},{"_id":"public/index.html","hash":"5b0b9a3623fbe586fb88735ecb5649062b360717","modified":1698843010139},{"_id":"public/tags/心情/index.html","hash":"2c7c76f59f3aea0d2c9a3d6b18bbd7a0747c45a0","modified":1698843010139},{"_id":"public/tags/Markdown/index.html","hash":"422c59564a19b8286b3524008ff980d1bf341d66","modified":1698843010139},{"_id":"public/tags/介绍/index.html","hash":"d169f18700a7fd8949245cd515c0c84eaec68269","modified":1698843010139},{"_id":"public/tags/OLED屏幕/index.html","hash":"e74f641142ad80903826641c5bd448176cd6eb9a","modified":1698843010139},{"_id":"public/tags/LCD屏幕/index.html","hash":"7c5867dead750648d8f44e97b4ebd746ab0da648","modified":1698843010139},{"_id":"public/tags/tcp-ip/index.html","hash":"56133a1102000d9088d491bd6038ba060ca8460f","modified":1698843010139},{"_id":"public/tags/http-https/index.html","hash":"96ca5b000ffdaf0cd1211da1b3f17f6a46960301","modified":1698843010139},{"_id":"public/images/loading.gif","hash":"9c840c5c3e7b97a184deb390df2f6926d6161708","modified":1698125810687},{"_id":"public/dist/APlayer.min.css.map","hash":"c59d2bc9472922cf6ef9a99e052dbee6cc7e6b36","modified":1698125810687},{"_id":"public/js/fireworks.js","hash":"ce6d90a46e18761366759c9ebede471bad9b72a1","modified":1698125810687},{"_id":"public/js/background.min.js","hash":"0b75485c0e7e4c1c00728408b814900ba5103def","modified":1698125810687},{"_id":"public/js/fireworks.min.js","hash":"6f5ccef48af055cb6f4419b6b6d5990678cb502c","modified":1698125810687},{"_id":"public/js/main.js","hash":"a9cb52bac89783c3957c77cbb4ffc8fbb93a92a1","modified":1698125810687},{"_id":"public/dist/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1698125810687},{"_id":"public/dist/music.js","hash":"4816a43c8a4f01d58d22b2f44f1882fa5b2257fd","modified":1698125810687},{"_id":"public/js/lib/crypto.js","hash":"bc4a0c41cf5b61faa204a2a820fc042b563142cf","modified":1698125810687},{"_id":"public/js/lib/home.js","hash":"c2bf22772fd052cff88a9b5f547a30a6eb97e545","modified":1698125810687},{"_id":"public/js/lib/highlight.js","hash":"df5760ee865f7f2e7e294a9ad154a10d4619bbb2","modified":1698125810687},{"_id":"public/js/lib/preview.js","hash":"595cfc3aff107b8dd0fdda214995c6f1bb5be39a","modified":1698125810687},{"_id":"public/js/lib/search.js","hash":"b631b87fa126a9a4a81b60b1a0516f765879963e","modified":1698125810687},{"_id":"public/js/lib/math.js","hash":"24c182cd3f5dd1c0f0192ca4cc143de71e076d2a","modified":1698125810687},{"_id":"public/css/main.css","hash":"444ff8856c320913dde037c43f24bba18ef4d741","modified":1698125810687},{"_id":"public/dist/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1698125810687},{"_id":"public/dist/APlayer.min.js.map","hash":"31a19da0f0cb6b00ec212eafa847f31af86788df","modified":1698125810687},{"_id":"public/images/5.jpg","hash":"38ca90744828d44fd85fb8c3867dcb2d23b060d2","modified":1698125810687},{"_id":"public/images/loading2.gif","hash":"526f25dedd49aebc4c1851c639c51818e16b65ed","modified":1698125810687},{"_id":"public/images/avatar.jpg","hash":"cd5b921252d1a4f15e17858f4f816ba768a6acf7","modified":1698125810687},{"_id":"public/images/4.jpg","hash":"d2da2f7cf6db15b06d7215ec91d6eaeef1dfae15","modified":1698125810687},{"_id":"public/images/6.jpg","hash":"d4cd5b1193bcf15f9420ee92a321ab62b5b8c452","modified":1698125810687},{"_id":"public/images/1.jpg","hash":"b36e0043c3166dbe84a2ec5aee6893f4ce88db58","modified":1698125810687},{"_id":"public/images/2.jpg","hash":"89dfb6a3957e6c19e04a21ae180d354fdcd4a58f","modified":1698125810687},{"_id":"public/images/background.png","hash":"13cb9dc559e65a8ee4fa4b2b7bee22ef741c078b","modified":1698125810687},{"_id":"public/images/3.png","hash":"8e2f57697681ae9affc4f6bc2227b6df8f2e65e0","modified":1698125810687},{"_id":"public/images/hello.png","hash":"e86689cc67b2299de0db966032ff348853970458","modified":1698125810687},{"_id":"source/_posts/图床搭建.md","hash":"66b4a7c998143f5780468edf077d6511e0020175","modified":1698683034133},{"_id":"source/_posts/stm32f407初学.md","hash":"d069c3ae4ca91ae51b88261fa217f6681facc701","modified":1698200268429},{"_id":"public/2023/10/24/图床搭建/index.html","hash":"da5438cb4981c6785ef8347157e16e006f2d0dec","modified":1698843010139},{"_id":"public/2023/10/24/stm32f407初学/index.html","hash":"62eb0c0107d1fe84f176f2e0b3e4579f31f48bab","modified":1698843010139},{"_id":"public/categories/单片机/index.html","hash":"e8658d6fb0ae79486a71fe6ee3ecc76302353961","modified":1698843010139},{"_id":"public/tags/M4内核/index.html","hash":"7a92260cee699522ec493d00fbe181c4800d806a","modified":1698843010139},{"_id":"public/tags/stm32/index.html","hash":"af54f0925a52f89266329a73d0fd15281be7b26b","modified":1698843010139},{"_id":"public/categories/网络与云服务/index.html","hash":"40c63dcbe8d65cabacc7cb48df8eb1d6cb176265","modified":1698843010139},{"_id":"public/categories/网络与云服务/技术教程/index.html","hash":"94a7304cb8c980d1d553a5f8e5087610a899e3b4","modified":1698843010139},{"_id":"public/tags/图床搭建/index.html","hash":"582e63fcd9ec5c629e8c73f387e490d82bff674e","modified":1698843010139},{"_id":"public/tags/云存储/index.html","hash":"1edb9220474a53b8f6b9c1e7684330f2c5f69250","modified":1698843010139},{"_id":"source/_posts/MQTT协议快速入门.md","hash":"1f1fa312d9e7035fb27c03f21dd682a2785109ad","modified":1698680343719},{"_id":"source/_posts/MQTT协议浅析.md","hash":"38e260263056f5073c84afe540a2e51dda3c8153","modified":1698714465403},{"_id":"public/2023/10/31/MQTT协议浅析/index.html","hash":"dc50662d99ed95a6a692f22c7909a0210db25043","modified":1698683076611},{"_id":"public/categories/通信协议/index.html","hash":"739bdd6f5315ab876369a806aefbd801472bde2f","modified":1698843010139},{"_id":"public/tags/mqtt/index.html","hash":"9a32543ad40000324f6a7ec2da99aaed57dcbd00","modified":1698843010139},{"_id":"public/tags/主题和负载/index.html","hash":"591c80784958f908d54f123c35ad7c385aea6490","modified":1698843010139},{"_id":"public/tags/发布和订阅/index.html","hash":"338bca64733742a154bde75822a370bfbcd1c47b","modified":1698843010139},{"_id":"source/_posts/git——分布式管理系统的入门与进阶.md","hash":"29ec1fd2cae6a693b414477ff397db73f41ba93b","modified":1698722797440},{"_id":"public/2023/10/26/MQTT协议浅析/index.html","hash":"56a82caeae96a4c2fc9c0d70822cb33a35ff734c","modified":1698843010139},{"_id":"source/_posts/git.md","hash":"b5ec137a67742a30d0a948c35f2db7113e22c3b9","modified":1698723127048},{"_id":"public/categories/版本控制系统/index.html","hash":"226a0c21884fa0caca1fa0cc3c9ffe8fc65ba677","modified":1698843010139},{"_id":"public/tags/git/index.html","hash":"44c1e177dd84160943e6916b1718ac1304c3ffa2","modified":1698843010139},{"_id":"public/tags/分布式管理系统/index.html","hash":"081653f5c73cb6ac24a2232172fb95c4b60edab1","modified":1698843010139},{"_id":"public/2023/10/31/git/index.html","hash":"9991a8b1d337b738f473aa9161dd3c4eed227e28","modified":1698723136299},{"_id":"source/_posts/git——分布式管理系统的入门与进阶（二）.md","hash":"f772b4516db4a0b3aea647e039b478657f66e367","modified":1698733709850},{"_id":"source/_posts/git入门与进阶.md","hash":"288ac048c58f0cda01ba0f75c484b92434d8da81","modified":1698730889695},{"_id":"public/2023/10/31/git入门与进阶/index.html","hash":"f09506af761ebed914dbd7ca8d2a40610d9ffd7f","modified":1698731060412},{"_id":"public/2023/10/31/git——分布式管理系统的入门与进阶（二）/index.html","hash":"ea66b9284b23350fe43c94d1bd8e259cd447948f","modified":1698843010139},{"_id":"source/_posts/git入门与进阶（一）.md","hash":"288ac048c58f0cda01ba0f75c484b92434d8da81","modified":1698730889695},{"_id":"public/2023/10/31/git入门与进阶（一）/index.html","hash":"60e9ef354c9b1dc181c49bf1617e68c77c6b7f83","modified":1698767530299},{"_id":"source/_posts/git入门与进阶-四.md","hash":"55a2af41415a0951c499f569de2101c387d89546","modified":1698755911830},{"_id":"source/_posts/git入门与进阶（三）.md","hash":"ae058290d3021f15cbd04b7063be1ced564c58d5","modified":1698741192315},{"_id":"public/2023/10/31/git入门与进阶-四/index.html","hash":"652a82dc9a1adccb77e4be0e0544adf969be3448","modified":1698843010139},{"_id":"public/2023/10/31/git入门与进阶（三）/index.html","hash":"d9299d865e700f00a214a7e3cb13cc2036dca434","modified":1698843010139},{"_id":"public/page/2/index.html","hash":"bdeeb99b7372cde60ab42d625ecb0f12572932ba","modified":1698843010139},{"_id":"public/archives/page/2/index.html","hash":"bf5b5ebd84d41c076d3e8d25d26b441d4d073119","modified":1698843010139},{"_id":"public/archives/2023/page/2/index.html","hash":"ef7df410e6cede8ffb06670eed0affc5ae5f2c1d","modified":1698843010139},{"_id":"public/tags/工作区/index.html","hash":"43de27df1ac94b94160b02ccb5549062c41ef4ec","modified":1698843010139},{"_id":"public/tags/暂存区/index.html","hash":"808f55266ac237c338609214e2a474acdab02a66","modified":1698843010139},{"_id":"source/_posts/git5.md","hash":"8bfc41599a35ca252661c5878ecd80373994fa98","modified":1698767522835},{"_id":"public/2023/10/31/git5/index.html","hash":"6b839ff52ace0c0e800541b3941753fc26302020","modified":1698843010139},{"_id":"public/tags/管理修改/index.html","hash":"e6cb45fee4e394403cf2ab9f9dca5a1a5e0431f1","modified":1698843010139},{"_id":"source/_posts/git入门与进阶-六.md","hash":"34baabbf1d7f6bfb5442e866ed43c7191e4a4362","modified":1698842999439},{"_id":"public/2023/11/01/git入门与进阶-六/index.html","hash":"da888a7b7458b0ac6b0023a3855101b2a0122542","modified":1698843010139},{"_id":"public/tags/撤销修改/index.html","hash":"b844efe85cd0abea6b91e688b3641da8d394995c","modified":1698843010139},{"_id":"public/tags/删除/index.html","hash":"0eabb679c096200f5e2767fabef7ea553333c01d","modified":1698843010139},{"_id":"public/archives/2023/11/index.html","hash":"3eb6d78b55b990a2edb2d181a93fcddf02bbe835","modified":1698843010139}],"Category":[{"name":"杂谈","_id":"clo3w9is400048kvv3g324cpi"},{"name":"编辑器","_id":"clo3w9is9000a8kvv0o5cf0yj"},{"name":"元器件","_id":"clo3w9isb000e8kvv0mfqe9am"},{"name":"网络协议","_id":"clo3w9isb000h8kvv7z921sqa"},{"name":"单片机","_id":"clo4h74za0002c0vv46xc3owh"},{"name":"网络与云服务","_id":"clo4hcg920000g4vv1fi94t6o"},{"name":"技术教程","parent":"clo4hcg920000g4vv1fi94t6o","_id":"clo4hcg940003g4vvaamv8htf"},{"name":"通信协议","_id":"clod407i20001q4vv4qqva50y"},{"name":"版本控制系统","_id":"clodrw1ri0001y4vv5ivm6j7j"}],"Data":[],"Page":[{"title":"about","date":"2023-10-17T03:40:21.000Z","_content":"## 👀长官，您瞧\n给你点颜色瞧瞧\n<span style=\"background-color: #ff0000;\">这是红色。</span>\n<span style=\"background-color: #ffa500;\">这是橙色。</span>\n<span style=\"background-color: #ffff00;\">这是黄色。</span>\n<span style=\"background-color: #00ff00;\">这是绿色。</span>\n<span style=\"background-color: #0000ff;\">这是蓝色。</span>\n<span style=\"background-color: #4b0082;\">这是靛蓝色。</span>\n<span style=\"background-color: #800080;\">这是紫色。</span>\n\n## 💡语言\n- 🦄C++ \t\t *长路漫漫，我系渣渣*\n- 🐍Python \t*人生苦短，我用Python*\n- 汉语\n> （这不废话吗）   \n\n##  :sparkles: 账户\n\n| Website  | Account|\n|:--|---|\n| QQ | 571971536 |\n| GitHub | [Echoo-Jiang](https://github.com/Echoo-Jiang) |\n| Bilibili | [笑笑默默哭](https://space.bilibili.com/24971853) |\n| 邮箱 | ckzx159@163.com |\n| Pornhub | 这个真没有 |\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2023-10-17 11:40:21\n---\n## 👀长官，您瞧\n给你点颜色瞧瞧\n<span style=\"background-color: #ff0000;\">这是红色。</span>\n<span style=\"background-color: #ffa500;\">这是橙色。</span>\n<span style=\"background-color: #ffff00;\">这是黄色。</span>\n<span style=\"background-color: #00ff00;\">这是绿色。</span>\n<span style=\"background-color: #0000ff;\">这是蓝色。</span>\n<span style=\"background-color: #4b0082;\">这是靛蓝色。</span>\n<span style=\"background-color: #800080;\">这是紫色。</span>\n\n## 💡语言\n- 🦄C++ \t\t *长路漫漫，我系渣渣*\n- 🐍Python \t*人生苦短，我用Python*\n- 汉语\n> （这不废话吗）   \n\n##  :sparkles: 账户\n\n| Website  | Account|\n|:--|---|\n| QQ | 571971536 |\n| GitHub | [Echoo-Jiang](https://github.com/Echoo-Jiang) |\n| Bilibili | [笑笑默默哭](https://space.bilibili.com/24971853) |\n| 邮箱 | ckzx159@163.com |\n| Pornhub | 这个真没有 |\n","updated":"2023-10-17T06:11:06.756Z","path":"about/index.html","comments":1,"layout":"page","_id":"clo3w9iru00008kvv7j0egjbt","content":"<h2 id=\"👀长官，您瞧\"><a href=\"#👀长官，您瞧\" class=\"headerlink\" title=\"👀长官，您瞧\"></a>👀长官，您瞧</h2><p>给你点颜色瞧瞧<br><span style=\"background-color: #ff0000;\">这是红色。</span><br><span style=\"background-color: #ffa500;\">这是橙色。</span><br><span style=\"background-color: #ffff00;\">这是黄色。</span><br><span style=\"background-color: #00ff00;\">这是绿色。</span><br><span style=\"background-color: #0000ff;\">这是蓝色。</span><br><span style=\"background-color: #4b0082;\">这是靛蓝色。</span><br><span style=\"background-color: #800080;\">这是紫色。</span></p>\n<h2 id=\"💡语言\"><a href=\"#💡语言\" class=\"headerlink\" title=\"💡语言\"></a>💡语言</h2><ul>\n<li>🦄C++ \t\t <em>长路漫漫，我系渣渣</em></li>\n<li>🐍Python \t<em>人生苦短，我用Python</em></li>\n<li>汉语<blockquote>\n<p>（这不废话吗）</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"sparkles-账户\"><a href=\"#sparkles-账户\" class=\"headerlink\" title=\":sparkles: 账户\"></a>:sparkles: 账户</h2><table>\n<thead>\n<tr>\n<th align=\"left\">Website</th>\n<th>Account</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">QQ</td>\n<td>571971536</td>\n</tr>\n<tr>\n<td align=\"left\">GitHub</td>\n<td><a href=\"https://github.com/Echoo-Jiang\">Echoo-Jiang</a></td>\n</tr>\n<tr>\n<td align=\"left\">Bilibili</td>\n<td><a href=\"https://space.bilibili.com/24971853\">笑笑默默哭</a></td>\n</tr>\n<tr>\n<td align=\"left\">邮箱</td>\n<td><a href=\"mailto:&#99;&#107;&#122;&#x78;&#x31;&#x35;&#x39;&#64;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#109;\">&#99;&#107;&#122;&#x78;&#x31;&#x35;&#x39;&#64;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#109;</a></td>\n</tr>\n<tr>\n<td align=\"left\">Pornhub</td>\n<td>这个真没有</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"👀长官，您瞧\"><a href=\"#👀长官，您瞧\" class=\"headerlink\" title=\"👀长官，您瞧\"></a>👀长官，您瞧</h2><p>给你点颜色瞧瞧<br><span style=\"background-color: #ff0000;\">这是红色。</span><br><span style=\"background-color: #ffa500;\">这是橙色。</span><br><span style=\"background-color: #ffff00;\">这是黄色。</span><br><span style=\"background-color: #00ff00;\">这是绿色。</span><br><span style=\"background-color: #0000ff;\">这是蓝色。</span><br><span style=\"background-color: #4b0082;\">这是靛蓝色。</span><br><span style=\"background-color: #800080;\">这是紫色。</span></p>\n<h2 id=\"💡语言\"><a href=\"#💡语言\" class=\"headerlink\" title=\"💡语言\"></a>💡语言</h2><ul>\n<li>🦄C++ \t\t <em>长路漫漫，我系渣渣</em></li>\n<li>🐍Python \t<em>人生苦短，我用Python</em></li>\n<li>汉语<blockquote>\n<p>（这不废话吗）</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"sparkles-账户\"><a href=\"#sparkles-账户\" class=\"headerlink\" title=\":sparkles: 账户\"></a>:sparkles: 账户</h2><table>\n<thead>\n<tr>\n<th align=\"left\">Website</th>\n<th>Account</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">QQ</td>\n<td>571971536</td>\n</tr>\n<tr>\n<td align=\"left\">GitHub</td>\n<td><a href=\"https://github.com/Echoo-Jiang\">Echoo-Jiang</a></td>\n</tr>\n<tr>\n<td align=\"left\">Bilibili</td>\n<td><a href=\"https://space.bilibili.com/24971853\">笑笑默默哭</a></td>\n</tr>\n<tr>\n<td align=\"left\">邮箱</td>\n<td><a href=\"mailto:&#99;&#107;&#122;&#x78;&#x31;&#x35;&#x39;&#64;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#109;\">&#99;&#107;&#122;&#x78;&#x31;&#x35;&#x39;&#64;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#109;</a></td>\n</tr>\n<tr>\n<td align=\"left\">Pornhub</td>\n<td>这个真没有</td>\n</tr>\n</tbody></table>\n"},{"title":"categories","date":"2023-10-17T06:31:41.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2023-10-17 14:31:41\ntype: categories\n---\n","updated":"2023-10-17T06:53:17.346Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clo3w9is100028kvvg7mtgtl6","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"musics","type":"musics","layout":"musics","_content":"\n","source":"musics/index.md","raw":"---\ntitle: musics\ntype: \"musics\"\nlayout: \"musics\"\n---\n\n","date":"2023-10-24T04:56:23.544Z","updated":"2023-10-24T04:56:11.685Z","path":"musics/index.html","comments":1,"_id":"clo3w9is600068kvvf9q43wdr","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2023-10-17T06:31:41.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2023-10-17 14:31:41\ntype: tags\n---\n","updated":"2023-10-17T06:39:26.986Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clo3w9is800088kvv2jde4xe9","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"你好世界","date":"2023-07-27T13:27:54.000Z","_content":" 分享一首我很喜欢的诗来表达我的心情吧  \n\n <!-- more -->\n\n## 一颗开花的树   \n\n​\t\t如何让你遇见我\n\n　　在我最美丽的时刻\n\n　　为这\n\n　　我已在佛前求了五百年\n\n　　求佛让我们结一段尘缘\n\n　　佛於是把我化做一棵树\n\n　　长在你必经的路旁\n\n　　阳光下\n\n　　慎重地开满了花\n\n![你好](/images/hello.png)\n> 来源pixiv ASK大佬\n\n{% aplayerlist %}\n{\n    \"autoplay\": true,\n    \"showlrc\": 0,\n    \"mutex\": true,\n    \"music\": [\n        {\n            \"title\": \"에필로그 (Epilogue)\",\n            \"author\": \"이동준\",\n            \"url\": \"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%8B%E1%85%A6%E1%84%91%E1%85%B5%E1%86%AF%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3.mp3\",\n            \"pic\": \"https://y.gtimg.cn/music/photo_new/T002R300x300M000000RmZHf3qhLUL.jpg?max_age=2592000\",\n            \"lrc\": \"https://歌词.lrc\"\n        }\n    ]\n}\n{% endaplayerlist %}\n","source":"_posts/Hello-World-1.md","raw":"---\ntitle: 你好世界\ndate: 2023-07-27 21:27:54\ntags: 心情\ncategories: 杂谈\n---\n 分享一首我很喜欢的诗来表达我的心情吧  \n\n <!-- more -->\n\n## 一颗开花的树   \n\n​\t\t如何让你遇见我\n\n　　在我最美丽的时刻\n\n　　为这\n\n　　我已在佛前求了五百年\n\n　　求佛让我们结一段尘缘\n\n　　佛於是把我化做一棵树\n\n　　长在你必经的路旁\n\n　　阳光下\n\n　　慎重地开满了花\n\n![你好](/images/hello.png)\n> 来源pixiv ASK大佬\n\n{% aplayerlist %}\n{\n    \"autoplay\": true,\n    \"showlrc\": 0,\n    \"mutex\": true,\n    \"music\": [\n        {\n            \"title\": \"에필로그 (Epilogue)\",\n            \"author\": \"이동준\",\n            \"url\": \"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%8B%E1%85%A6%E1%84%91%E1%85%B5%E1%86%AF%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3.mp3\",\n            \"pic\": \"https://y.gtimg.cn/music/photo_new/T002R300x300M000000RmZHf3qhLUL.jpg?max_age=2592000\",\n            \"lrc\": \"https://歌词.lrc\"\n        }\n    ]\n}\n{% endaplayerlist %}\n","slug":"Hello-World-1","published":1,"updated":"2023-10-24T05:09:18.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clo3w9irx00018kvvfsnj1w29","content":"<p> 分享一首我很喜欢的诗来表达我的心情吧  </p>\n <span id=\"more\"></span>\n\n<h2 id=\"一颗开花的树\"><a href=\"#一颗开花的树\" class=\"headerlink\" title=\"一颗开花的树\"></a>一颗开花的树</h2><p>​\t\t如何让你遇见我</p>\n<p>　　在我最美丽的时刻</p>\n<p>　　为这</p>\n<p>　　我已在佛前求了五百年</p>\n<p>　　求佛让我们结一段尘缘</p>\n<p>　　佛於是把我化做一棵树</p>\n<p>　　长在你必经的路旁</p>\n<p>　　阳光下</p>\n<p>　　慎重地开满了花</p>\n<p><img src=\"/images/hello.png\" alt=\"你好\"></p>\n<blockquote>\n<p>来源pixiv ASK大佬</p>\n</blockquote>\n\n        <div id=\"aplayer-boBLIFly\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t  <script>\n\t\t\t\t  var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":0,\"mutex\":true,\"music\":[{\"title\":\"에필로그 (Epilogue)\",\"author\":\"이동준\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%8B%E1%85%A6%E1%84%91%E1%85%B5%E1%86%AF%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M000000RmZHf3qhLUL.jpg?max_age=2592000\",\"lrc\":\"https://歌词.lrc\"}]};\n\t\t\t\t  options.element = document.getElementById(\"aplayer-boBLIFly\");\n\t\t\t\t  var ap = new APlayer(options);\n\t\t\t    window.aplayers || (window.aplayers = []);\n\t\t\t\t  window.aplayers.push(ap);\n\t\t\t  </script>\n","site":{"data":{}},"excerpt":"<p> 分享一首我很喜欢的诗来表达我的心情吧  </p>","more":"<h2 id=\"一颗开花的树\"><a href=\"#一颗开花的树\" class=\"headerlink\" title=\"一颗开花的树\"></a>一颗开花的树</h2><p>​\t\t如何让你遇见我</p>\n<p>　　在我最美丽的时刻</p>\n<p>　　为这</p>\n<p>　　我已在佛前求了五百年</p>\n<p>　　求佛让我们结一段尘缘</p>\n<p>　　佛於是把我化做一棵树</p>\n<p>　　长在你必经的路旁</p>\n<p>　　阳光下</p>\n<p>　　慎重地开满了花</p>\n<p><img src=\"/images/hello.png\" alt=\"你好\"></p>\n<blockquote>\n<p>来源pixiv ASK大佬</p>\n</blockquote>\n\n        <div id=\"aplayer-boBLIFly\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t  <script>\n\t\t\t\t  var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":0,\"mutex\":true,\"music\":[{\"title\":\"에필로그 (Epilogue)\",\"author\":\"이동준\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%8B%E1%85%A6%E1%84%91%E1%85%B5%E1%86%AF%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M000000RmZHf3qhLUL.jpg?max_age=2592000\",\"lrc\":\"https://歌词.lrc\"}]};\n\t\t\t\t  options.element = document.getElementById(\"aplayer-boBLIFly\");\n\t\t\t\t  var ap = new APlayer(options);\n\t\t\t    window.aplayers || (window.aplayers = []);\n\t\t\t\t  window.aplayers.push(ap);\n\t\t\t  </script>"},{"title":"Markdown语法简介","date":"2023-06-23T13:14:04.000Z","_content":"\n> 对markdown的格式简单介绍\n\n<!--more-->\n# 标题\n\n在行首加#号，表示标题等级，一个#号表示一级标题，两个#号表示二级标题，最多可用六级标题。\n\n# 一级标题\n\n## 二级标题\n\n### 三级标题\n\n# 列表\n\n无序列表使用-或*，有序列表使用数字加.，并且.后需要空格。\n\n- 无序列表1\n- 无序列表2\n\n1. 有序列表1\n2. 有序列表2\n\n# 强调\n\n使用*或_包裹要强调的文本，一个*或_表示斜体，两个*或_表示加粗。\n\n*斜体* **加粗**\n\n# 图片和链接\n\n插入图片：![图片描述](链接地址)，插入链接：[链接描述](链接地址)。\n\n![图片描述](链接地址) [链接描述](链接地址)\n引用\n使用>表示引用，可以嵌套。\n>引用\n>>引用\n代码块\n\n使用```表示代码块。后面可以添加程序语言名称\n```c++\n代码块1\n代码块2\n```\n分割线\n使用三个以上的-、*等表示分割线。\n\n---\n\n# 表格\n\n使用|、-等字符表示表格。\n\n| 表头1   | 表头2   |\n| ---- | ------- |\n| 单元格1 | 单元格2 |\n\n# 删除线\n\n使用\\~~包裹要删除的文本。\n\n~~删除~~文本\n\n# 转义字符\n\n使用\\字符转义特殊字符。\n\n\\*这是一个普通的星号\\*\n\n# 自动链接\n\n使用<>可以将URL和电子邮件地址自动转成链接。\n\n[https://www.example.com](https://www.example.com/) [email@example.com](mailto:email@example.com)\n<ckzx159@163.com>\n\n# 行内代码块\n\n使用`包裹要标记的`代码`。\n\n这是`代码`的说明","source":"_posts/Markdown语法简介.md","raw":"---\ntitle: Markdown语法简介\ndate: 2023-6-23 21:14:04\ntags:\n- Markdown\n- 介绍\ncategories: 编辑器\n---\n\n> 对markdown的格式简单介绍\n\n<!--more-->\n# 标题\n\n在行首加#号，表示标题等级，一个#号表示一级标题，两个#号表示二级标题，最多可用六级标题。\n\n# 一级标题\n\n## 二级标题\n\n### 三级标题\n\n# 列表\n\n无序列表使用-或*，有序列表使用数字加.，并且.后需要空格。\n\n- 无序列表1\n- 无序列表2\n\n1. 有序列表1\n2. 有序列表2\n\n# 强调\n\n使用*或_包裹要强调的文本，一个*或_表示斜体，两个*或_表示加粗。\n\n*斜体* **加粗**\n\n# 图片和链接\n\n插入图片：![图片描述](链接地址)，插入链接：[链接描述](链接地址)。\n\n![图片描述](链接地址) [链接描述](链接地址)\n引用\n使用>表示引用，可以嵌套。\n>引用\n>>引用\n代码块\n\n使用```表示代码块。后面可以添加程序语言名称\n```c++\n代码块1\n代码块2\n```\n分割线\n使用三个以上的-、*等表示分割线。\n\n---\n\n# 表格\n\n使用|、-等字符表示表格。\n\n| 表头1   | 表头2   |\n| ---- | ------- |\n| 单元格1 | 单元格2 |\n\n# 删除线\n\n使用\\~~包裹要删除的文本。\n\n~~删除~~文本\n\n# 转义字符\n\n使用\\字符转义特殊字符。\n\n\\*这是一个普通的星号\\*\n\n# 自动链接\n\n使用<>可以将URL和电子邮件地址自动转成链接。\n\n[https://www.example.com](https://www.example.com/) [email@example.com](mailto:email@example.com)\n<ckzx159@163.com>\n\n# 行内代码块\n\n使用`包裹要标记的`代码`。\n\n这是`代码`的说明","slug":"Markdown语法简介","published":1,"updated":"2023-10-23T15:39:52.647Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clo3w9is200038kvveutze2sb","content":"<blockquote>\n<p>对markdown的格式简单介绍</p>\n</blockquote>\n<span id=\"more\"></span>\n<h1 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h1><p>在行首加#号，表示标题等级，一个#号表示一级标题，两个#号表示二级标题，最多可用六级标题。</p>\n<h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h1 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h1><p>无序列表使用-或*，有序列表使用数字加.，并且.后需要空格。</p>\n<ul>\n<li>无序列表1</li>\n<li>无序列表2</li>\n</ul>\n<ol>\n<li>有序列表1</li>\n<li>有序列表2</li>\n</ol>\n<h1 id=\"强调\"><a href=\"#强调\" class=\"headerlink\" title=\"强调\"></a>强调</h1><p>使用<em>或_包裹要强调的文本，一个</em>或_表示斜体，两个*或_表示加粗。</p>\n<p><em>斜体</em> <strong>加粗</strong></p>\n<h1 id=\"图片和链接\"><a href=\"#图片和链接\" class=\"headerlink\" title=\"图片和链接\"></a>图片和链接</h1><p>插入图片：<img src=\"/%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80\" alt=\"图片描述\">，插入链接：<a href=\"%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80\">链接描述</a>。</p>\n<p><img src=\"/%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80\" alt=\"图片描述\"> <a href=\"%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80\">链接描述</a><br>引用<br>使用&gt;表示引用，可以嵌套。</p>\n<blockquote>\n<p>引用</p>\n<blockquote>\n<p>引用<br>代码块</p>\n</blockquote>\n</blockquote>\n<p>使用&#96;&#96;&#96;表示代码块。后面可以添加程序语言名称</p>\n<pre><code class=\"c++\">代码块1\n代码块2\n</code></pre>\n<p>分割线<br>使用三个以上的-、*等表示分割线。</p>\n<hr>\n<h1 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h1><p>使用|、-等字符表示表格。</p>\n<table>\n<thead>\n<tr>\n<th>表头1</th>\n<th>表头2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>单元格1</td>\n<td>单元格2</td>\n</tr>\n</tbody></table>\n<h1 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h1><p>使用~~包裹要删除的文本。</p>\n<p><del>删除</del>文本</p>\n<h1 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h1><p>使用\\字符转义特殊字符。</p>\n<p>*这是一个普通的星号*</p>\n<h1 id=\"自动链接\"><a href=\"#自动链接\" class=\"headerlink\" title=\"自动链接\"></a>自动链接</h1><p>使用&lt;&gt;可以将URL和电子邮件地址自动转成链接。</p>\n<p><a href=\"https://www.example.com/\">https://www.example.com</a> <a href=\"mailto:email@example.com\">email@example.com</a><br><a href=\"mailto:&#99;&#107;&#122;&#x78;&#x31;&#53;&#x39;&#x40;&#x31;&#x36;&#51;&#46;&#99;&#x6f;&#x6d;\">&#99;&#107;&#122;&#x78;&#x31;&#53;&#x39;&#x40;&#x31;&#x36;&#51;&#46;&#99;&#x6f;&#x6d;</a></p>\n<h1 id=\"行内代码块\"><a href=\"#行内代码块\" class=\"headerlink\" title=\"行内代码块\"></a>行内代码块</h1><p>使用<code>包裹要标记的</code>代码&#96;。</p>\n<p>这是<code>代码</code>的说明</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>对markdown的格式简单介绍</p>\n</blockquote>","more":"<h1 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h1><p>在行首加#号，表示标题等级，一个#号表示一级标题，两个#号表示二级标题，最多可用六级标题。</p>\n<h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h1 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h1><p>无序列表使用-或*，有序列表使用数字加.，并且.后需要空格。</p>\n<ul>\n<li>无序列表1</li>\n<li>无序列表2</li>\n</ul>\n<ol>\n<li>有序列表1</li>\n<li>有序列表2</li>\n</ol>\n<h1 id=\"强调\"><a href=\"#强调\" class=\"headerlink\" title=\"强调\"></a>强调</h1><p>使用<em>或_包裹要强调的文本，一个</em>或_表示斜体，两个*或_表示加粗。</p>\n<p><em>斜体</em> <strong>加粗</strong></p>\n<h1 id=\"图片和链接\"><a href=\"#图片和链接\" class=\"headerlink\" title=\"图片和链接\"></a>图片和链接</h1><p>插入图片：<img src=\"/%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80\" alt=\"图片描述\">，插入链接：<a href=\"%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80\">链接描述</a>。</p>\n<p><img src=\"/%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80\" alt=\"图片描述\"> <a href=\"%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80\">链接描述</a><br>引用<br>使用&gt;表示引用，可以嵌套。</p>\n<blockquote>\n<p>引用</p>\n<blockquote>\n<p>引用<br>代码块</p>\n</blockquote>\n</blockquote>\n<p>使用&#96;&#96;&#96;表示代码块。后面可以添加程序语言名称</p>\n<pre><code class=\"c++\">代码块1\n代码块2\n</code></pre>\n<p>分割线<br>使用三个以上的-、*等表示分割线。</p>\n<hr>\n<h1 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h1><p>使用|、-等字符表示表格。</p>\n<table>\n<thead>\n<tr>\n<th>表头1</th>\n<th>表头2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>单元格1</td>\n<td>单元格2</td>\n</tr>\n</tbody></table>\n<h1 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h1><p>使用~~包裹要删除的文本。</p>\n<p><del>删除</del>文本</p>\n<h1 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h1><p>使用\\字符转义特殊字符。</p>\n<p>*这是一个普通的星号*</p>\n<h1 id=\"自动链接\"><a href=\"#自动链接\" class=\"headerlink\" title=\"自动链接\"></a>自动链接</h1><p>使用&lt;&gt;可以将URL和电子邮件地址自动转成链接。</p>\n<p><a href=\"https://www.example.com/\">https://www.example.com</a> <a href=\"mailto:email@example.com\">email@example.com</a><br><a href=\"mailto:&#99;&#107;&#122;&#x78;&#x31;&#53;&#x39;&#x40;&#x31;&#x36;&#51;&#46;&#99;&#x6f;&#x6d;\">&#99;&#107;&#122;&#x78;&#x31;&#53;&#x39;&#x40;&#x31;&#x36;&#51;&#46;&#99;&#x6f;&#x6d;</a></p>\n<h1 id=\"行内代码块\"><a href=\"#行内代码块\" class=\"headerlink\" title=\"行内代码块\"></a>行内代码块</h1><p>使用<code>包裹要标记的</code>代码&#96;。</p>\n<p>这是<code>代码</code>的说明</p>"},{"title":"OLED和LCD屏幕的区别","date":"2023-10-17T08:15:16.000Z","_content":"\nOLED和LCD都是常出现的屏幕。\n\n本文探讨一下OLED（有机发光二极管）和LCD（液晶显示）区别。\n\n<!--more-->\n\n## 发光源\nLCD的发光源只能发出白光\n\n采用液晶材料，控制电压来调节透过液晶的光的多少。\n\n加入3种有颜色的透光薄膜即可组成成千上万的颜色。   \t\t\t (*也就是rgb*)\n\n由于使用电压控制，不能实现真正意义上的黑屏，但也因此可以连续调节光的强度。\n\nOLED直接使用led发出3种颜色的光\n\n没有了液晶和背光板，因此厚度仅为LCD的3分之1。\t\t\t *(手机折叠屏的基础)*\n\nOLED通过led的闪烁来降低led亮灯总时间，以达到控制光照亮度的目的。\t\t\t *(类似视觉暂留的原理)*\n\n实现纯黑的方法就是熄灭led，简单节能，缺点是频闪，看旧了伤眼睛。\n\n## 烧屏\n由于OLED是每个像素点都独自用了LED自发光，那么同时也就会产生问题：每个像素点的使用时间不相同。当\n\n某些像素点使用时间过长提前老化，就会产生一块屏幕有几个“点”永远印在屏幕上，这就是所谓的“烧屏”。OLED\n\n使用有机材料，更易老化，“烧屏”问题无法忽视。\n\n\n\n总的来说，OLED与LCD各有优劣，但OLED的发展应该会逐渐拉开两者差距。","source":"_posts/OLED和LCD屏幕的区别.md","raw":"---\ntitle: OLED和LCD屏幕的区别\ndate: 2023-10-17 16:15:16\ntags:\n  - OLED屏幕\n  - LCD屏幕\ncategories: 元器件\n---\n\nOLED和LCD都是常出现的屏幕。\n\n本文探讨一下OLED（有机发光二极管）和LCD（液晶显示）区别。\n\n<!--more-->\n\n## 发光源\nLCD的发光源只能发出白光\n\n采用液晶材料，控制电压来调节透过液晶的光的多少。\n\n加入3种有颜色的透光薄膜即可组成成千上万的颜色。   \t\t\t (*也就是rgb*)\n\n由于使用电压控制，不能实现真正意义上的黑屏，但也因此可以连续调节光的强度。\n\nOLED直接使用led发出3种颜色的光\n\n没有了液晶和背光板，因此厚度仅为LCD的3分之1。\t\t\t *(手机折叠屏的基础)*\n\nOLED通过led的闪烁来降低led亮灯总时间，以达到控制光照亮度的目的。\t\t\t *(类似视觉暂留的原理)*\n\n实现纯黑的方法就是熄灭led，简单节能，缺点是频闪，看旧了伤眼睛。\n\n## 烧屏\n由于OLED是每个像素点都独自用了LED自发光，那么同时也就会产生问题：每个像素点的使用时间不相同。当\n\n某些像素点使用时间过长提前老化，就会产生一块屏幕有几个“点”永远印在屏幕上，这就是所谓的“烧屏”。OLED\n\n使用有机材料，更易老化，“烧屏”问题无法忽视。\n\n\n\n总的来说，OLED与LCD各有优劣，但OLED的发展应该会逐渐拉开两者差距。","slug":"OLED和LCD屏幕的区别","published":1,"updated":"2023-10-17T11:49:41.182Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clo3w9is600078kvv0gf92dhm","content":"<p>OLED和LCD都是常出现的屏幕。</p>\n<p>本文探讨一下OLED（有机发光二极管）和LCD（液晶显示）区别。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"发光源\"><a href=\"#发光源\" class=\"headerlink\" title=\"发光源\"></a>发光源</h2><p>LCD的发光源只能发出白光</p>\n<p>采用液晶材料，控制电压来调节透过液晶的光的多少。</p>\n<p>加入3种有颜色的透光薄膜即可组成成千上万的颜色。   \t\t\t (<em>也就是rgb</em>)</p>\n<p>由于使用电压控制，不能实现真正意义上的黑屏，但也因此可以连续调节光的强度。</p>\n<p>OLED直接使用led发出3种颜色的光</p>\n<p>没有了液晶和背光板，因此厚度仅为LCD的3分之1。\t\t\t <em>(手机折叠屏的基础)</em></p>\n<p>OLED通过led的闪烁来降低led亮灯总时间，以达到控制光照亮度的目的。\t\t\t <em>(类似视觉暂留的原理)</em></p>\n<p>实现纯黑的方法就是熄灭led，简单节能，缺点是频闪，看旧了伤眼睛。</p>\n<h2 id=\"烧屏\"><a href=\"#烧屏\" class=\"headerlink\" title=\"烧屏\"></a>烧屏</h2><p>由于OLED是每个像素点都独自用了LED自发光，那么同时也就会产生问题：每个像素点的使用时间不相同。当</p>\n<p>某些像素点使用时间过长提前老化，就会产生一块屏幕有几个“点”永远印在屏幕上，这就是所谓的“烧屏”。OLED</p>\n<p>使用有机材料，更易老化，“烧屏”问题无法忽视。</p>\n<p>总的来说，OLED与LCD各有优劣，但OLED的发展应该会逐渐拉开两者差距。</p>\n","site":{"data":{}},"excerpt":"<p>OLED和LCD都是常出现的屏幕。</p>\n<p>本文探讨一下OLED（有机发光二极管）和LCD（液晶显示）区别。</p>","more":"<h2 id=\"发光源\"><a href=\"#发光源\" class=\"headerlink\" title=\"发光源\"></a>发光源</h2><p>LCD的发光源只能发出白光</p>\n<p>采用液晶材料，控制电压来调节透过液晶的光的多少。</p>\n<p>加入3种有颜色的透光薄膜即可组成成千上万的颜色。   \t\t\t (<em>也就是rgb</em>)</p>\n<p>由于使用电压控制，不能实现真正意义上的黑屏，但也因此可以连续调节光的强度。</p>\n<p>OLED直接使用led发出3种颜色的光</p>\n<p>没有了液晶和背光板，因此厚度仅为LCD的3分之1。\t\t\t <em>(手机折叠屏的基础)</em></p>\n<p>OLED通过led的闪烁来降低led亮灯总时间，以达到控制光照亮度的目的。\t\t\t <em>(类似视觉暂留的原理)</em></p>\n<p>实现纯黑的方法就是熄灭led，简单节能，缺点是频闪，看旧了伤眼睛。</p>\n<h2 id=\"烧屏\"><a href=\"#烧屏\" class=\"headerlink\" title=\"烧屏\"></a>烧屏</h2><p>由于OLED是每个像素点都独自用了LED自发光，那么同时也就会产生问题：每个像素点的使用时间不相同。当</p>\n<p>某些像素点使用时间过长提前老化，就会产生一块屏幕有几个“点”永远印在屏幕上，这就是所谓的“烧屏”。OLED</p>\n<p>使用有机材料，更易老化，“烧屏”问题无法忽视。</p>\n<p>总的来说，OLED与LCD各有优劣，但OLED的发展应该会逐渐拉开两者差距。</p>"},{"title":"网络基础知识","date":"2023-10-20T07:43:29.000Z","_content":"TCP/IP协议指的不仅仅是TCP和IP两个协议。还包括UDP、FTP、SMTP等协议。本章先简单比较TCP与UDP。\n<!--more-->\n\n# 可靠性\n\nTCP基于连接。它在通信阶段开始时建立一个连接，在此连接上传输数据，传输完成后终止连接。 _因此可靠。_\nUDP基于非连接。UDP不需要事先建立连接，直接将数据包发送出去，不关心数据是否到达。 _因此不可靠。_\n\n## TCP有以下机制：\n\n1. 数据包校验（16位校验和）\n2. 确认序列号\n3. 丢弃多余重复包\n4. 确认应答\n5. 超时重传\n6. 流量控制\n7. 拥塞控制\n\n## UDP无以上机制\n校验和出错时，会直接丢弃报文\n\n## 速度：\n- 由于TCP需要通过三次握手来建立连接，并且还要进行数据完整性校验和顺序控制，所以相比之下，TCP的传输速度比UDP慢。\n- UDP没有这些过程，因此在传输速度上通常比TCP快。\n## 数据传输顺序：\n- TCP保证了数据传输的顺序，即数据会按照其被发送的顺序送达接收方。\n- UDP则不能保证数据的顺序，数据包可能会以任何顺序到达。\n## 使用场景：\n- TCP主要用于需要高可靠性的应用，如网络文件传输，电子邮件传输，Web页面加载等。\n- UDP则常常用于实时应用如视频流，音频流，网络游戏等，这些应用对速度要求高，可以容忍一些数据包的丢失。\n## 数据通信单元\n- TCP：TCP 将应用层数据切分为合适大小的数据块，并封装到TCP段（segment）中进行传输。每一个TCP段在被发送之前，都会附加TCP首部信息，包含如序列号、确认号、校验和等信息，这些信息都便于数据的可靠传输和错误恢复。\n\n- UDP：UDP 直接将应用层数据封装为一个数据报（Datagram）进行发送。每个UDP数据报在头部只包括了基本的信息，如源端口号、目标端口号、长度和校验和。","source":"_posts/网络服务器软件测试开发技术.md","raw":"---\ntitle: 网络基础知识\ndate: 2023-10-20 15:43:29\ntags:\n- tcp/ip\n- http/https\ncategories: 网络协议\n---\nTCP/IP协议指的不仅仅是TCP和IP两个协议。还包括UDP、FTP、SMTP等协议。本章先简单比较TCP与UDP。\n<!--more-->\n\n# 可靠性\n\nTCP基于连接。它在通信阶段开始时建立一个连接，在此连接上传输数据，传输完成后终止连接。 _因此可靠。_\nUDP基于非连接。UDP不需要事先建立连接，直接将数据包发送出去，不关心数据是否到达。 _因此不可靠。_\n\n## TCP有以下机制：\n\n1. 数据包校验（16位校验和）\n2. 确认序列号\n3. 丢弃多余重复包\n4. 确认应答\n5. 超时重传\n6. 流量控制\n7. 拥塞控制\n\n## UDP无以上机制\n校验和出错时，会直接丢弃报文\n\n## 速度：\n- 由于TCP需要通过三次握手来建立连接，并且还要进行数据完整性校验和顺序控制，所以相比之下，TCP的传输速度比UDP慢。\n- UDP没有这些过程，因此在传输速度上通常比TCP快。\n## 数据传输顺序：\n- TCP保证了数据传输的顺序，即数据会按照其被发送的顺序送达接收方。\n- UDP则不能保证数据的顺序，数据包可能会以任何顺序到达。\n## 使用场景：\n- TCP主要用于需要高可靠性的应用，如网络文件传输，电子邮件传输，Web页面加载等。\n- UDP则常常用于实时应用如视频流，音频流，网络游戏等，这些应用对速度要求高，可以容忍一些数据包的丢失。\n## 数据通信单元\n- TCP：TCP 将应用层数据切分为合适大小的数据块，并封装到TCP段（segment）中进行传输。每一个TCP段在被发送之前，都会附加TCP首部信息，包含如序列号、确认号、校验和等信息，这些信息都便于数据的可靠传输和错误恢复。\n\n- UDP：UDP 直接将应用层数据封装为一个数据报（Datagram）进行发送。每个UDP数据报在头部只包括了基本的信息，如源端口号、目标端口号、长度和校验和。","slug":"网络服务器软件测试开发技术","published":1,"updated":"2023-10-23T15:38:31.023Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clo3w9is800098kvv3en10had","content":"<p>TCP&#x2F;IP协议指的不仅仅是TCP和IP两个协议。还包括UDP、FTP、SMTP等协议。本章先简单比较TCP与UDP。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"可靠性\"><a href=\"#可靠性\" class=\"headerlink\" title=\"可靠性\"></a>可靠性</h1><p>TCP基于连接。它在通信阶段开始时建立一个连接，在此连接上传输数据，传输完成后终止连接。 <em>因此可靠。</em><br>UDP基于非连接。UDP不需要事先建立连接，直接将数据包发送出去，不关心数据是否到达。 <em>因此不可靠。</em></p>\n<h2 id=\"TCP有以下机制：\"><a href=\"#TCP有以下机制：\" class=\"headerlink\" title=\"TCP有以下机制：\"></a>TCP有以下机制：</h2><ol>\n<li>数据包校验（16位校验和）</li>\n<li>确认序列号</li>\n<li>丢弃多余重复包</li>\n<li>确认应答</li>\n<li>超时重传</li>\n<li>流量控制</li>\n<li>拥塞控制</li>\n</ol>\n<h2 id=\"UDP无以上机制\"><a href=\"#UDP无以上机制\" class=\"headerlink\" title=\"UDP无以上机制\"></a>UDP无以上机制</h2><p>校验和出错时，会直接丢弃报文</p>\n<h2 id=\"速度：\"><a href=\"#速度：\" class=\"headerlink\" title=\"速度：\"></a>速度：</h2><ul>\n<li>由于TCP需要通过三次握手来建立连接，并且还要进行数据完整性校验和顺序控制，所以相比之下，TCP的传输速度比UDP慢。</li>\n<li>UDP没有这些过程，因此在传输速度上通常比TCP快。</li>\n</ul>\n<h2 id=\"数据传输顺序：\"><a href=\"#数据传输顺序：\" class=\"headerlink\" title=\"数据传输顺序：\"></a>数据传输顺序：</h2><ul>\n<li>TCP保证了数据传输的顺序，即数据会按照其被发送的顺序送达接收方。</li>\n<li>UDP则不能保证数据的顺序，数据包可能会以任何顺序到达。</li>\n</ul>\n<h2 id=\"使用场景：\"><a href=\"#使用场景：\" class=\"headerlink\" title=\"使用场景：\"></a>使用场景：</h2><ul>\n<li>TCP主要用于需要高可靠性的应用，如网络文件传输，电子邮件传输，Web页面加载等。</li>\n<li>UDP则常常用于实时应用如视频流，音频流，网络游戏等，这些应用对速度要求高，可以容忍一些数据包的丢失。</li>\n</ul>\n<h2 id=\"数据通信单元\"><a href=\"#数据通信单元\" class=\"headerlink\" title=\"数据通信单元\"></a>数据通信单元</h2><ul>\n<li><p>TCP：TCP 将应用层数据切分为合适大小的数据块，并封装到TCP段（segment）中进行传输。每一个TCP段在被发送之前，都会附加TCP首部信息，包含如序列号、确认号、校验和等信息，这些信息都便于数据的可靠传输和错误恢复。</p>\n</li>\n<li><p>UDP：UDP 直接将应用层数据封装为一个数据报（Datagram）进行发送。每个UDP数据报在头部只包括了基本的信息，如源端口号、目标端口号、长度和校验和。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>TCP&#x2F;IP协议指的不仅仅是TCP和IP两个协议。还包括UDP、FTP、SMTP等协议。本章先简单比较TCP与UDP。</p>","more":"<h1 id=\"可靠性\"><a href=\"#可靠性\" class=\"headerlink\" title=\"可靠性\"></a>可靠性</h1><p>TCP基于连接。它在通信阶段开始时建立一个连接，在此连接上传输数据，传输完成后终止连接。 <em>因此可靠。</em><br>UDP基于非连接。UDP不需要事先建立连接，直接将数据包发送出去，不关心数据是否到达。 <em>因此不可靠。</em></p>\n<h2 id=\"TCP有以下机制：\"><a href=\"#TCP有以下机制：\" class=\"headerlink\" title=\"TCP有以下机制：\"></a>TCP有以下机制：</h2><ol>\n<li>数据包校验（16位校验和）</li>\n<li>确认序列号</li>\n<li>丢弃多余重复包</li>\n<li>确认应答</li>\n<li>超时重传</li>\n<li>流量控制</li>\n<li>拥塞控制</li>\n</ol>\n<h2 id=\"UDP无以上机制\"><a href=\"#UDP无以上机制\" class=\"headerlink\" title=\"UDP无以上机制\"></a>UDP无以上机制</h2><p>校验和出错时，会直接丢弃报文</p>\n<h2 id=\"速度：\"><a href=\"#速度：\" class=\"headerlink\" title=\"速度：\"></a>速度：</h2><ul>\n<li>由于TCP需要通过三次握手来建立连接，并且还要进行数据完整性校验和顺序控制，所以相比之下，TCP的传输速度比UDP慢。</li>\n<li>UDP没有这些过程，因此在传输速度上通常比TCP快。</li>\n</ul>\n<h2 id=\"数据传输顺序：\"><a href=\"#数据传输顺序：\" class=\"headerlink\" title=\"数据传输顺序：\"></a>数据传输顺序：</h2><ul>\n<li>TCP保证了数据传输的顺序，即数据会按照其被发送的顺序送达接收方。</li>\n<li>UDP则不能保证数据的顺序，数据包可能会以任何顺序到达。</li>\n</ul>\n<h2 id=\"使用场景：\"><a href=\"#使用场景：\" class=\"headerlink\" title=\"使用场景：\"></a>使用场景：</h2><ul>\n<li>TCP主要用于需要高可靠性的应用，如网络文件传输，电子邮件传输，Web页面加载等。</li>\n<li>UDP则常常用于实时应用如视频流，音频流，网络游戏等，这些应用对速度要求高，可以容忍一些数据包的丢失。</li>\n</ul>\n<h2 id=\"数据通信单元\"><a href=\"#数据通信单元\" class=\"headerlink\" title=\"数据通信单元\"></a>数据通信单元</h2><ul>\n<li><p>TCP：TCP 将应用层数据切分为合适大小的数据块，并封装到TCP段（segment）中进行传输。每一个TCP段在被发送之前，都会附加TCP首部信息，包含如序列号、确认号、校验和等信息，这些信息都便于数据的可靠传输和错误恢复。</p>\n</li>\n<li><p>UDP：UDP 直接将应用层数据封装为一个数据报（Datagram）进行发送。每个UDP数据报在头部只包括了基本的信息，如源端口号、目标端口号、长度和校验和。</p>\n</li>\n</ul>"},{"title":"stm32f4系列——M4内核的一些特点","date":"2023-10-24T13:29:21.000Z","_content":"\n> 32位Arm cortex M4处理器内核是Cortex-M中首款使用专用数字信号处理（DSP）IP单元（可重用的硬件设计模块）的内核。\n>\n> 它适合需要高效率、易于使用的控制和信号处理能力的数字信号控制应用。如IoT、电机控制、电源管理、嵌入式音频、工业和家居自动化等应用。\n\nM4的M意为Microcontroller，即微型控制器。\nM4拥有更高的工作时钟频率，更好的性能，更大的flsh和ram，一般来说还有更丰富的外设接口。\n\n<!--more-->\n\n为了更直观的体现M4的不同，这里拿M3系列（也许stm32f103就是大多数人第一次接触到Cortex-M系列）进行对比。\n\n| 系列           | 工作时钟频率(Mhz) | 性能(Coremark) | Flash(KB) | Ram(KB)  | 接口                  |\n| -------------- | ----------------- | -------------- | --------- | -------- | --------------------- |\n| M3             | 24 - 72           | 93 - 398       | 16 - 1024 | 4 - 128  | USART,SPI,I2C,USB,CAN |\n| M4(未考虑双核) | 72 - 180          | 245 - 613      | 16 - 2048 | 16 - 640 | 更丰富的接口          |\n\n以stm32f103与stm32f407为例（分别是M3、M4内核）作比较。两者在JTAG、看门狗、省电模式、CRC（数据校验）、芯片ID（均为96位的全球唯一id）等方面均相同。\n\n对引脚、GPIO端口、USART、DMA通道、I2C总线、ADC通道、CAN控制器都有数量上的提升。\n\n","source":"_posts/stm32f407初学.md","raw":"---\ntitle: stm32f4系列——M4内核的一些特点\ndate: 2023-10-24 21:29:21\ntags:\n- M4内核\n- stm32\ncategories: 单片机\n---\n\n> 32位Arm cortex M4处理器内核是Cortex-M中首款使用专用数字信号处理（DSP）IP单元（可重用的硬件设计模块）的内核。\n>\n> 它适合需要高效率、易于使用的控制和信号处理能力的数字信号控制应用。如IoT、电机控制、电源管理、嵌入式音频、工业和家居自动化等应用。\n\nM4的M意为Microcontroller，即微型控制器。\nM4拥有更高的工作时钟频率，更好的性能，更大的flsh和ram，一般来说还有更丰富的外设接口。\n\n<!--more-->\n\n为了更直观的体现M4的不同，这里拿M3系列（也许stm32f103就是大多数人第一次接触到Cortex-M系列）进行对比。\n\n| 系列           | 工作时钟频率(Mhz) | 性能(Coremark) | Flash(KB) | Ram(KB)  | 接口                  |\n| -------------- | ----------------- | -------------- | --------- | -------- | --------------------- |\n| M3             | 24 - 72           | 93 - 398       | 16 - 1024 | 4 - 128  | USART,SPI,I2C,USB,CAN |\n| M4(未考虑双核) | 72 - 180          | 245 - 613      | 16 - 2048 | 16 - 640 | 更丰富的接口          |\n\n以stm32f103与stm32f407为例（分别是M3、M4内核）作比较。两者在JTAG、看门狗、省电模式、CRC（数据校验）、芯片ID（均为96位的全球唯一id）等方面均相同。\n\n对引脚、GPIO端口、USART、DMA通道、I2C总线、ADC通道、CAN控制器都有数量上的提升。\n\n","slug":"stm32f407初学","published":1,"updated":"2023-10-25T02:17:48.429Z","_id":"clo4h74z20000c0vvdh5egppu","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>32位Arm cortex M4处理器内核是Cortex-M中首款使用专用数字信号处理（DSP）IP单元（可重用的硬件设计模块）的内核。</p>\n<p>它适合需要高效率、易于使用的控制和信号处理能力的数字信号控制应用。如IoT、电机控制、电源管理、嵌入式音频、工业和家居自动化等应用。</p>\n</blockquote>\n<p>M4的M意为Microcontroller，即微型控制器。<br>M4拥有更高的工作时钟频率，更好的性能，更大的flsh和ram，一般来说还有更丰富的外设接口。</p>\n<span id=\"more\"></span>\n\n<p>为了更直观的体现M4的不同，这里拿M3系列（也许stm32f103就是大多数人第一次接触到Cortex-M系列）进行对比。</p>\n<table>\n<thead>\n<tr>\n<th>系列</th>\n<th>工作时钟频率(Mhz)</th>\n<th>性能(Coremark)</th>\n<th>Flash(KB)</th>\n<th>Ram(KB)</th>\n<th>接口</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>M3</td>\n<td>24 - 72</td>\n<td>93 - 398</td>\n<td>16 - 1024</td>\n<td>4 - 128</td>\n<td>USART,SPI,I2C,USB,CAN</td>\n</tr>\n<tr>\n<td>M4(未考虑双核)</td>\n<td>72 - 180</td>\n<td>245 - 613</td>\n<td>16 - 2048</td>\n<td>16 - 640</td>\n<td>更丰富的接口</td>\n</tr>\n</tbody></table>\n<p>以stm32f103与stm32f407为例（分别是M3、M4内核）作比较。两者在JTAG、看门狗、省电模式、CRC（数据校验）、芯片ID（均为96位的全球唯一id）等方面均相同。</p>\n<p>对引脚、GPIO端口、USART、DMA通道、I2C总线、ADC通道、CAN控制器都有数量上的提升。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>32位Arm cortex M4处理器内核是Cortex-M中首款使用专用数字信号处理（DSP）IP单元（可重用的硬件设计模块）的内核。</p>\n<p>它适合需要高效率、易于使用的控制和信号处理能力的数字信号控制应用。如IoT、电机控制、电源管理、嵌入式音频、工业和家居自动化等应用。</p>\n</blockquote>\n<p>M4的M意为Microcontroller，即微型控制器。<br>M4拥有更高的工作时钟频率，更好的性能，更大的flsh和ram，一般来说还有更丰富的外设接口。</p>","more":"<p>为了更直观的体现M4的不同，这里拿M3系列（也许stm32f103就是大多数人第一次接触到Cortex-M系列）进行对比。</p>\n<table>\n<thead>\n<tr>\n<th>系列</th>\n<th>工作时钟频率(Mhz)</th>\n<th>性能(Coremark)</th>\n<th>Flash(KB)</th>\n<th>Ram(KB)</th>\n<th>接口</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>M3</td>\n<td>24 - 72</td>\n<td>93 - 398</td>\n<td>16 - 1024</td>\n<td>4 - 128</td>\n<td>USART,SPI,I2C,USB,CAN</td>\n</tr>\n<tr>\n<td>M4(未考虑双核)</td>\n<td>72 - 180</td>\n<td>245 - 613</td>\n<td>16 - 2048</td>\n<td>16 - 640</td>\n<td>更丰富的接口</td>\n</tr>\n</tbody></table>\n<p>以stm32f103与stm32f407为例（分别是M3、M4内核）作比较。两者在JTAG、看门狗、省电模式、CRC（数据校验）、芯片ID（均为96位的全球唯一id）等方面均相同。</p>\n<p>对引脚、GPIO端口、USART、DMA通道、I2C总线、ADC通道、CAN控制器都有数量上的提升。</p>"},{"title":"图床搭建","date":"2023-10-24T13:31:16.000Z","_content":"\n# 什么是图床？为什么要图床\n\n1. 本质就是管理图片的云服务器\n2. 可以帮助博客脱离图片附件\n3. 将图片转换成链接，访问链接即是访问图片\n4. 方便迁移markdown文档\n<!--more-->\n\n# 如何建立存储桶\n\n以腾讯云为例（其他云服务器也可，或者你有一台自己的服务器），登录后打开右上角的控制台。然后在上方搜索产品“对象存储”。\n左侧列表选择存储桶列表，创建存储桶。基本信息这一步骤要注意访问权限，由于图床的图需要被人访问，这里权限应该选择包含“公有读”的部分。第二步可选配置对图床没有帮助，可以直接跳过。<img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo%E2%80%98s%E5%9B%BE%E5%BA%8A/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231027135540.png?q-sign-algorithm=sha1&q-ak=AKIDSifIGzDIxK3dgYO3H3D9bPPRgRHpBAQZ_rXRSRr0jA3U1sB5RMeLvKIKrmXBa0yD&q-sign-time=1698681390;1698684990&q-key-time=1698681390;1698684990&q-header-list=host&q-url-param-list=ci-process&q-signature=eade89cc5bfed19f9bffb0049b95ef989f1999f7&x-cos-security-token=OpszgE95umSyj44mLzF5sAiMZyI00Aradeeb87abc7ee9480413646a602b1fc99yguaerzWxtIFpTAEXtu5GM5q4uQQ8mb8P9cU_MmNUH8G2UhmYVCF3pQrCASZmEYm-Aky9BCEEuLl3lHvhTLkLsGVzgCXWcmlK2dRJ9JVipnGVd941Sz31UAci__L4WYO69eSZVVYm-NV3G60TCDLLQhgMGtRZepKQWG_Rx4WbBuTW2pQvm4g_WnNrobGx9Vs&ci-process=originImage\" style=\"zoom: 50%;\" />\n创建完成后，恭喜你，你拥有了一个对象。~~当然不是你想的那个对象~~你可以在存储桶列表中找到它。\n_这种方法创建的图床每年大概需要消耗您的10元人民币_\n\n# 如何使用存储桶\n\n有了对象的之后，~~第一步自然是使用它了。~~点击它，选择文件列表，你可以创建一个文件夹，将图片手动上传（当然也可以直接不创文件夹直接上传图片）。\n你可以安装一个Picgo，进行关于腾讯云的相关配置之后，就能方便快捷地上传图片到图床了。\n具体腾讯云的配置如下。\ncos版本选择V5。Secretid secretkey appid的获取方式：左侧常用工具，密钥管理，前往访问密钥，即可生成以上三个信息。bukkit栏填入存储桶名称![image-20231031001645880](https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/image-20231031001645880.png)\n回到存储桶列表，找到ap-xxxxx信息填入存储空间名和确认存储区。存储路径即为之前创建的文件夹（也可以不填，那样就会保存到根目录下)，路径最后还加上/，否则最后的文件路径会被当作图片文件的前缀。\n填完所有必需的配置后，设置为默认图床。\n\n# picgo配合markdown工具自动上传图片\n\nobsidian可以使用插件image auto upload，typora可以直接设置。\n以typora为例，文件--->偏好设置---->图片--->插入图片时上传图片--->上传服务设为picgo app--->设置好路径。\n配置完成后，有一个好消息，你以后在typora中可以直接粘贴图片了（前提是打开picgo）。\n\n## 至此你已经配置好了一个实用的图床。\n\n","source":"_posts/图床搭建.md","raw":"---\ntitle: 图床搭建\ndate: 2023-10-24 21:31:16\ntags:\n- 图床搭建\n- 云存储\ncategories:\n- 网络与云服务\n- 技术教程\n---\n\n# 什么是图床？为什么要图床\n\n1. 本质就是管理图片的云服务器\n2. 可以帮助博客脱离图片附件\n3. 将图片转换成链接，访问链接即是访问图片\n4. 方便迁移markdown文档\n<!--more-->\n\n# 如何建立存储桶\n\n以腾讯云为例（其他云服务器也可，或者你有一台自己的服务器），登录后打开右上角的控制台。然后在上方搜索产品“对象存储”。\n左侧列表选择存储桶列表，创建存储桶。基本信息这一步骤要注意访问权限，由于图床的图需要被人访问，这里权限应该选择包含“公有读”的部分。第二步可选配置对图床没有帮助，可以直接跳过。<img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo%E2%80%98s%E5%9B%BE%E5%BA%8A/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231027135540.png?q-sign-algorithm=sha1&q-ak=AKIDSifIGzDIxK3dgYO3H3D9bPPRgRHpBAQZ_rXRSRr0jA3U1sB5RMeLvKIKrmXBa0yD&q-sign-time=1698681390;1698684990&q-key-time=1698681390;1698684990&q-header-list=host&q-url-param-list=ci-process&q-signature=eade89cc5bfed19f9bffb0049b95ef989f1999f7&x-cos-security-token=OpszgE95umSyj44mLzF5sAiMZyI00Aradeeb87abc7ee9480413646a602b1fc99yguaerzWxtIFpTAEXtu5GM5q4uQQ8mb8P9cU_MmNUH8G2UhmYVCF3pQrCASZmEYm-Aky9BCEEuLl3lHvhTLkLsGVzgCXWcmlK2dRJ9JVipnGVd941Sz31UAci__L4WYO69eSZVVYm-NV3G60TCDLLQhgMGtRZepKQWG_Rx4WbBuTW2pQvm4g_WnNrobGx9Vs&ci-process=originImage\" style=\"zoom: 50%;\" />\n创建完成后，恭喜你，你拥有了一个对象。~~当然不是你想的那个对象~~你可以在存储桶列表中找到它。\n_这种方法创建的图床每年大概需要消耗您的10元人民币_\n\n# 如何使用存储桶\n\n有了对象的之后，~~第一步自然是使用它了。~~点击它，选择文件列表，你可以创建一个文件夹，将图片手动上传（当然也可以直接不创文件夹直接上传图片）。\n你可以安装一个Picgo，进行关于腾讯云的相关配置之后，就能方便快捷地上传图片到图床了。\n具体腾讯云的配置如下。\ncos版本选择V5。Secretid secretkey appid的获取方式：左侧常用工具，密钥管理，前往访问密钥，即可生成以上三个信息。bukkit栏填入存储桶名称![image-20231031001645880](https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/image-20231031001645880.png)\n回到存储桶列表，找到ap-xxxxx信息填入存储空间名和确认存储区。存储路径即为之前创建的文件夹（也可以不填，那样就会保存到根目录下)，路径最后还加上/，否则最后的文件路径会被当作图片文件的前缀。\n填完所有必需的配置后，设置为默认图床。\n\n# picgo配合markdown工具自动上传图片\n\nobsidian可以使用插件image auto upload，typora可以直接设置。\n以typora为例，文件--->偏好设置---->图片--->插入图片时上传图片--->上传服务设为picgo app--->设置好路径。\n配置完成后，有一个好消息，你以后在typora中可以直接粘贴图片了（前提是打开picgo）。\n\n## 至此你已经配置好了一个实用的图床。\n\n","slug":"图床搭建","published":1,"updated":"2023-10-30T16:23:54.133Z","_id":"clo4h74z80001c0vvhc3z3b95","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"什么是图床？为什么要图床\"><a href=\"#什么是图床？为什么要图床\" class=\"headerlink\" title=\"什么是图床？为什么要图床\"></a>什么是图床？为什么要图床</h1><ol>\n<li>本质就是管理图片的云服务器</li>\n<li>可以帮助博客脱离图片附件</li>\n<li>将图片转换成链接，访问链接即是访问图片</li>\n<li>方便迁移markdown文档<span id=\"more\"></span></li>\n</ol>\n<h1 id=\"如何建立存储桶\"><a href=\"#如何建立存储桶\" class=\"headerlink\" title=\"如何建立存储桶\"></a>如何建立存储桶</h1><p>以腾讯云为例（其他云服务器也可，或者你有一台自己的服务器），登录后打开右上角的控制台。然后在上方搜索产品“对象存储”。<br>左侧列表选择存储桶列表，创建存储桶。基本信息这一步骤要注意访问权限，由于图床的图需要被人访问，这里权限应该选择包含“公有读”的部分。第二步可选配置对图床没有帮助，可以直接跳过。<img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo%E2%80%98s%E5%9B%BE%E5%BA%8A/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231027135540.png?q-sign-algorithm=sha1&q-ak=AKIDSifIGzDIxK3dgYO3H3D9bPPRgRHpBAQZ_rXRSRr0jA3U1sB5RMeLvKIKrmXBa0yD&q-sign-time=1698681390;1698684990&q-key-time=1698681390;1698684990&q-header-list=host&q-url-param-list=ci-process&q-signature=eade89cc5bfed19f9bffb0049b95ef989f1999f7&x-cos-security-token=OpszgE95umSyj44mLzF5sAiMZyI00Aradeeb87abc7ee9480413646a602b1fc99yguaerzWxtIFpTAEXtu5GM5q4uQQ8mb8P9cU_MmNUH8G2UhmYVCF3pQrCASZmEYm-Aky9BCEEuLl3lHvhTLkLsGVzgCXWcmlK2dRJ9JVipnGVd941Sz31UAci__L4WYO69eSZVVYm-NV3G60TCDLLQhgMGtRZepKQWG_Rx4WbBuTW2pQvm4g_WnNrobGx9Vs&ci-process=originImage\" style=\"zoom: 50%;\" /><br>创建完成后，恭喜你，你拥有了一个对象。<del>当然不是你想的那个对象</del>你可以在存储桶列表中找到它。<br><em>这种方法创建的图床每年大概需要消耗您的10元人民币</em></p>\n<h1 id=\"如何使用存储桶\"><a href=\"#如何使用存储桶\" class=\"headerlink\" title=\"如何使用存储桶\"></a>如何使用存储桶</h1><p>有了对象的之后，<del>第一步自然是使用它了。</del>点击它，选择文件列表，你可以创建一个文件夹，将图片手动上传（当然也可以直接不创文件夹直接上传图片）。<br>你可以安装一个Picgo，进行关于腾讯云的相关配置之后，就能方便快捷地上传图片到图床了。<br>具体腾讯云的配置如下。<br>cos版本选择V5。Secretid secretkey appid的获取方式：左侧常用工具，密钥管理，前往访问密钥，即可生成以上三个信息。bukkit栏填入存储桶名称<img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/image-20231031001645880.png\" alt=\"image-20231031001645880\"><br>回到存储桶列表，找到ap-xxxxx信息填入存储空间名和确认存储区。存储路径即为之前创建的文件夹（也可以不填，那样就会保存到根目录下)，路径最后还加上&#x2F;，否则最后的文件路径会被当作图片文件的前缀。<br>填完所有必需的配置后，设置为默认图床。</p>\n<h1 id=\"picgo配合markdown工具自动上传图片\"><a href=\"#picgo配合markdown工具自动上传图片\" class=\"headerlink\" title=\"picgo配合markdown工具自动上传图片\"></a>picgo配合markdown工具自动上传图片</h1><p>obsidian可以使用插件image auto upload，typora可以直接设置。<br>以typora为例，文件—&gt;偏好设置—-&gt;图片—&gt;插入图片时上传图片—&gt;上传服务设为picgo app—&gt;设置好路径。<br>配置完成后，有一个好消息，你以后在typora中可以直接粘贴图片了（前提是打开picgo）。</p>\n<h2 id=\"至此你已经配置好了一个实用的图床。\"><a href=\"#至此你已经配置好了一个实用的图床。\" class=\"headerlink\" title=\"至此你已经配置好了一个实用的图床。\"></a>至此你已经配置好了一个实用的图床。</h2>","site":{"data":{}},"excerpt":"<h1 id=\"什么是图床？为什么要图床\"><a href=\"#什么是图床？为什么要图床\" class=\"headerlink\" title=\"什么是图床？为什么要图床\"></a>什么是图床？为什么要图床</h1><ol>\n<li>本质就是管理图片的云服务器</li>\n<li>可以帮助博客脱离图片附件</li>\n<li>将图片转换成链接，访问链接即是访问图片</li>\n<li>方便迁移markdown文档","more":"</li>\n</ol>\n<h1 id=\"如何建立存储桶\"><a href=\"#如何建立存储桶\" class=\"headerlink\" title=\"如何建立存储桶\"></a>如何建立存储桶</h1><p>以腾讯云为例（其他云服务器也可，或者你有一台自己的服务器），登录后打开右上角的控制台。然后在上方搜索产品“对象存储”。<br>左侧列表选择存储桶列表，创建存储桶。基本信息这一步骤要注意访问权限，由于图床的图需要被人访问，这里权限应该选择包含“公有读”的部分。第二步可选配置对图床没有帮助，可以直接跳过。<img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo%E2%80%98s%E5%9B%BE%E5%BA%8A/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231027135540.png?q-sign-algorithm=sha1&q-ak=AKIDSifIGzDIxK3dgYO3H3D9bPPRgRHpBAQZ_rXRSRr0jA3U1sB5RMeLvKIKrmXBa0yD&q-sign-time=1698681390;1698684990&q-key-time=1698681390;1698684990&q-header-list=host&q-url-param-list=ci-process&q-signature=eade89cc5bfed19f9bffb0049b95ef989f1999f7&x-cos-security-token=OpszgE95umSyj44mLzF5sAiMZyI00Aradeeb87abc7ee9480413646a602b1fc99yguaerzWxtIFpTAEXtu5GM5q4uQQ8mb8P9cU_MmNUH8G2UhmYVCF3pQrCASZmEYm-Aky9BCEEuLl3lHvhTLkLsGVzgCXWcmlK2dRJ9JVipnGVd941Sz31UAci__L4WYO69eSZVVYm-NV3G60TCDLLQhgMGtRZepKQWG_Rx4WbBuTW2pQvm4g_WnNrobGx9Vs&ci-process=originImage\" style=\"zoom: 50%;\" /><br>创建完成后，恭喜你，你拥有了一个对象。<del>当然不是你想的那个对象</del>你可以在存储桶列表中找到它。<br><em>这种方法创建的图床每年大概需要消耗您的10元人民币</em></p>\n<h1 id=\"如何使用存储桶\"><a href=\"#如何使用存储桶\" class=\"headerlink\" title=\"如何使用存储桶\"></a>如何使用存储桶</h1><p>有了对象的之后，<del>第一步自然是使用它了。</del>点击它，选择文件列表，你可以创建一个文件夹，将图片手动上传（当然也可以直接不创文件夹直接上传图片）。<br>你可以安装一个Picgo，进行关于腾讯云的相关配置之后，就能方便快捷地上传图片到图床了。<br>具体腾讯云的配置如下。<br>cos版本选择V5。Secretid secretkey appid的获取方式：左侧常用工具，密钥管理，前往访问密钥，即可生成以上三个信息。bukkit栏填入存储桶名称<img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/image-20231031001645880.png\" alt=\"image-20231031001645880\"><br>回到存储桶列表，找到ap-xxxxx信息填入存储空间名和确认存储区。存储路径即为之前创建的文件夹（也可以不填，那样就会保存到根目录下)，路径最后还加上&#x2F;，否则最后的文件路径会被当作图片文件的前缀。<br>填完所有必需的配置后，设置为默认图床。</p>\n<h1 id=\"picgo配合markdown工具自动上传图片\"><a href=\"#picgo配合markdown工具自动上传图片\" class=\"headerlink\" title=\"picgo配合markdown工具自动上传图片\"></a>picgo配合markdown工具自动上传图片</h1><p>obsidian可以使用插件image auto upload，typora可以直接设置。<br>以typora为例，文件—&gt;偏好设置—-&gt;图片—&gt;插入图片时上传图片—&gt;上传服务设为picgo app—&gt;设置好路径。<br>配置完成后，有一个好消息，你以后在typora中可以直接粘贴图片了（前提是打开picgo）。</p>\n<h2 id=\"至此你已经配置好了一个实用的图床。\"><a href=\"#至此你已经配置好了一个实用的图床。\" class=\"headerlink\" title=\"至此你已经配置好了一个实用的图床。\"></a>至此你已经配置好了一个实用的图床。</h2>"},{"title":"MQTT协议浅析","date":"2023-10-25T16:21:04.000Z","_content":"\n## 模式\n\nmqtt是发布/订阅的模式，客户端可以订阅感兴趣的主题，并接收与该主题相关的消息。\n\n<!--more-->\n\n## 结构\n\n是中心分布，其他物联网设备连接到同一个服务端。每个物联网节点都可以作为一个发布者或者订阅者。发布者publish给服务器，订阅者subcribe从服务器。\n\n## 消息结构\n\n- topic，是一个字符串。当订阅者和发布者使用同名的topic时，它们之间就会自动构建连接。topic通过`/`来区分层级,如：\n  `chat/room/1\n  sensor/10/temperature\n  sensor/+/temperature`\n\n  MQTT  topic支持以下两种通配符：`+` 和 `#`。\n\n  - `+`：表示单层通配符，例如 `a/+` 匹配 `a/x` 或 `a/y`。\n\n  - `#`：表示多层通配符，例如 `a/#` 匹配 `a/x`、`a/b/c/d`。\n\n  > **注意**：通配符主题只能用于订阅，不能用于发布。\n\n- payload，实际传输的内容，消息的主体部分。\n\n## 轻量化特性\n\nMQTT 开销低、报文小的特点使其非常适合物联网设备，因为它消耗更少的资源。\n\n## 支持许多编程语言\n\nMQTT是一个开放的协议，因此获得了广泛的语言支持。\n\n## broker\n\nMQTT Broker 是负责处理客户端请求的关键组件，包括建立连接、断开连接、订阅和取消订阅等操作，同时还负责消息的转发。\n\n## QoS(服务质量)\n\nmqtt提供了三种服务质量，在不同网络环境下保证消息的可靠性。\n\n- QoS 0：消息最多传送一次。如果当前客户端不可用，它将丢失这条消息。\n- QoS 1：消息至少传送一次。\n- QoS 2：消息只传送一次。\n\n## 基本工作流程\n\n1. 客户端使用TCP/IP协议与broke建立连接，可选TLS/SSL加密。\n2. 客户端可以向特定topic发布消息，也可订阅topic接收消息。\n3. broker接受发布的消息，并转发给订阅了对应topic的客户端。根据QoS等级确保消息可靠传递。\n\n## 搭建mqtt broker\n\n首先选择一个合适的MQTT服务器软件，这里推荐常用的EMQX。它适用于物联网、工业物联网和车联网。可以通过docker命令来安装emqx。\n\n```docker\ndocker run -d --name emqx -p 1883:1883 -p 8083:8083 -p 8084:8084 -p 8883:8883 -p 18083:18083 emqx/emqx\n```\n\n## mqtt客户端测试\n\n推荐使用MQTTX，它可以方便地与Broker进行交互，提升开发和调试的效率。它可以快速创建链接保存并同时建立多个连接客户端。\n\n以下是一个[免费公共 MQTT Broker](https://www.emqx.com/zh/mqtt/public-mqtt5-broker)，它基于完全托管的 [MQTT 云服务 - EMQX Cloud](https://www.emqx.com/zh/cloud) 创建。服务器信息如下：\n\n> Server: `broker.emqx.io`\n>\n> TCP Port: `1883`\n>\n> WebSocket Port: `8083`\n>\n> SSL/TLS Port: `8883`\n>\n> Secure WebSocket Port: `8084`\n\n## 保留消息Retain\n\n当 MQTT 客户端向服务器发布消息时，可以设置保留消息标志。保留消息存储在消息服务器上，后续订阅该主题的客户端仍然可以收到该消息。\n\n## clean session\n\n如果客户端连接时设置 Clean Session 为 false，并且使用相同的客户端 ID 再次上线，那么消息服务器将为客户端缓存一定数量的离线消息，并在它重新上线时发送给它。\n\n## 遗嘱消息Last Will\n\n如果 MQTT 客户端异常离线（在断开连接前没有向服务器发送 DISCONNECT 消息），MQTT 服务器会发布遗嘱消息。\n","source":"_posts/MQTT协议浅析.md","raw":"---\ntitle: MQTT协议浅析\ndate: 2023-10-26 00:21:04\ntags:\n- mqtt\n- 主题和负载\n- 发布和订阅\ncategories:\n- 通信协议\n---\n\n## 模式\n\nmqtt是发布/订阅的模式，客户端可以订阅感兴趣的主题，并接收与该主题相关的消息。\n\n<!--more-->\n\n## 结构\n\n是中心分布，其他物联网设备连接到同一个服务端。每个物联网节点都可以作为一个发布者或者订阅者。发布者publish给服务器，订阅者subcribe从服务器。\n\n## 消息结构\n\n- topic，是一个字符串。当订阅者和发布者使用同名的topic时，它们之间就会自动构建连接。topic通过`/`来区分层级,如：\n  `chat/room/1\n  sensor/10/temperature\n  sensor/+/temperature`\n\n  MQTT  topic支持以下两种通配符：`+` 和 `#`。\n\n  - `+`：表示单层通配符，例如 `a/+` 匹配 `a/x` 或 `a/y`。\n\n  - `#`：表示多层通配符，例如 `a/#` 匹配 `a/x`、`a/b/c/d`。\n\n  > **注意**：通配符主题只能用于订阅，不能用于发布。\n\n- payload，实际传输的内容，消息的主体部分。\n\n## 轻量化特性\n\nMQTT 开销低、报文小的特点使其非常适合物联网设备，因为它消耗更少的资源。\n\n## 支持许多编程语言\n\nMQTT是一个开放的协议，因此获得了广泛的语言支持。\n\n## broker\n\nMQTT Broker 是负责处理客户端请求的关键组件，包括建立连接、断开连接、订阅和取消订阅等操作，同时还负责消息的转发。\n\n## QoS(服务质量)\n\nmqtt提供了三种服务质量，在不同网络环境下保证消息的可靠性。\n\n- QoS 0：消息最多传送一次。如果当前客户端不可用，它将丢失这条消息。\n- QoS 1：消息至少传送一次。\n- QoS 2：消息只传送一次。\n\n## 基本工作流程\n\n1. 客户端使用TCP/IP协议与broke建立连接，可选TLS/SSL加密。\n2. 客户端可以向特定topic发布消息，也可订阅topic接收消息。\n3. broker接受发布的消息，并转发给订阅了对应topic的客户端。根据QoS等级确保消息可靠传递。\n\n## 搭建mqtt broker\n\n首先选择一个合适的MQTT服务器软件，这里推荐常用的EMQX。它适用于物联网、工业物联网和车联网。可以通过docker命令来安装emqx。\n\n```docker\ndocker run -d --name emqx -p 1883:1883 -p 8083:8083 -p 8084:8084 -p 8883:8883 -p 18083:18083 emqx/emqx\n```\n\n## mqtt客户端测试\n\n推荐使用MQTTX，它可以方便地与Broker进行交互，提升开发和调试的效率。它可以快速创建链接保存并同时建立多个连接客户端。\n\n以下是一个[免费公共 MQTT Broker](https://www.emqx.com/zh/mqtt/public-mqtt5-broker)，它基于完全托管的 [MQTT 云服务 - EMQX Cloud](https://www.emqx.com/zh/cloud) 创建。服务器信息如下：\n\n> Server: `broker.emqx.io`\n>\n> TCP Port: `1883`\n>\n> WebSocket Port: `8083`\n>\n> SSL/TLS Port: `8883`\n>\n> Secure WebSocket Port: `8084`\n\n## 保留消息Retain\n\n当 MQTT 客户端向服务器发布消息时，可以设置保留消息标志。保留消息存储在消息服务器上，后续订阅该主题的客户端仍然可以收到该消息。\n\n## clean session\n\n如果客户端连接时设置 Clean Session 为 false，并且使用相同的客户端 ID 再次上线，那么消息服务器将为客户端缓存一定数量的离线消息，并在它重新上线时发送给它。\n\n## 遗嘱消息Last Will\n\n如果 MQTT 客户端异常离线（在断开连接前没有向服务器发送 DISCONNECT 消息），MQTT 服务器会发布遗嘱消息。\n","slug":"MQTT协议浅析","published":1,"updated":"2023-10-31T01:07:45.403Z","_id":"clod3x3d20000q4vv0w6g3v7t","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"模式\"><a href=\"#模式\" class=\"headerlink\" title=\"模式\"></a>模式</h2><p>mqtt是发布&#x2F;订阅的模式，客户端可以订阅感兴趣的主题，并接收与该主题相关的消息。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h2><p>是中心分布，其他物联网设备连接到同一个服务端。每个物联网节点都可以作为一个发布者或者订阅者。发布者publish给服务器，订阅者subcribe从服务器。</p>\n<h2 id=\"消息结构\"><a href=\"#消息结构\" class=\"headerlink\" title=\"消息结构\"></a>消息结构</h2><ul>\n<li><p>topic，是一个字符串。当订阅者和发布者使用同名的topic时，它们之间就会自动构建连接。topic通过<code>/</code>来区分层级,如：<br><code>chat/room/1 sensor/10/temperature sensor/+/temperature</code></p>\n<p>MQTT  topic支持以下两种通配符：<code>+</code> 和 <code>#</code>。</p>\n<ul>\n<li><p><code>+</code>：表示单层通配符，例如 <code>a/+</code> 匹配 <code>a/x</code> 或 <code>a/y</code>。</p>\n</li>\n<li><p><code>#</code>：表示多层通配符，例如 <code>a/#</code> 匹配 <code>a/x</code>、<code>a/b/c/d</code>。</p>\n</li>\n</ul>\n<blockquote>\n<p><strong>注意</strong>：通配符主题只能用于订阅，不能用于发布。</p>\n</blockquote>\n</li>\n<li><p>payload，实际传输的内容，消息的主体部分。</p>\n</li>\n</ul>\n<h2 id=\"轻量化特性\"><a href=\"#轻量化特性\" class=\"headerlink\" title=\"轻量化特性\"></a>轻量化特性</h2><p>MQTT 开销低、报文小的特点使其非常适合物联网设备，因为它消耗更少的资源。</p>\n<h2 id=\"支持许多编程语言\"><a href=\"#支持许多编程语言\" class=\"headerlink\" title=\"支持许多编程语言\"></a>支持许多编程语言</h2><p>MQTT是一个开放的协议，因此获得了广泛的语言支持。</p>\n<h2 id=\"broker\"><a href=\"#broker\" class=\"headerlink\" title=\"broker\"></a>broker</h2><p>MQTT Broker 是负责处理客户端请求的关键组件，包括建立连接、断开连接、订阅和取消订阅等操作，同时还负责消息的转发。</p>\n<h2 id=\"QoS-服务质量\"><a href=\"#QoS-服务质量\" class=\"headerlink\" title=\"QoS(服务质量)\"></a>QoS(服务质量)</h2><p>mqtt提供了三种服务质量，在不同网络环境下保证消息的可靠性。</p>\n<ul>\n<li>QoS 0：消息最多传送一次。如果当前客户端不可用，它将丢失这条消息。</li>\n<li>QoS 1：消息至少传送一次。</li>\n<li>QoS 2：消息只传送一次。</li>\n</ul>\n<h2 id=\"基本工作流程\"><a href=\"#基本工作流程\" class=\"headerlink\" title=\"基本工作流程\"></a>基本工作流程</h2><ol>\n<li>客户端使用TCP&#x2F;IP协议与broke建立连接，可选TLS&#x2F;SSL加密。</li>\n<li>客户端可以向特定topic发布消息，也可订阅topic接收消息。</li>\n<li>broker接受发布的消息，并转发给订阅了对应topic的客户端。根据QoS等级确保消息可靠传递。</li>\n</ol>\n<h2 id=\"搭建mqtt-broker\"><a href=\"#搭建mqtt-broker\" class=\"headerlink\" title=\"搭建mqtt broker\"></a>搭建mqtt broker</h2><p>首先选择一个合适的MQTT服务器软件，这里推荐常用的EMQX。它适用于物联网、工业物联网和车联网。可以通过docker命令来安装emqx。</p>\n<pre><code class=\"docker\">docker run -d --name emqx -p 1883:1883 -p 8083:8083 -p 8084:8084 -p 8883:8883 -p 18083:18083 emqx/emqx\n</code></pre>\n<h2 id=\"mqtt客户端测试\"><a href=\"#mqtt客户端测试\" class=\"headerlink\" title=\"mqtt客户端测试\"></a>mqtt客户端测试</h2><p>推荐使用MQTTX，它可以方便地与Broker进行交互，提升开发和调试的效率。它可以快速创建链接保存并同时建立多个连接客户端。</p>\n<p>以下是一个<a href=\"https://www.emqx.com/zh/mqtt/public-mqtt5-broker\">免费公共 MQTT Broker</a>，它基于完全托管的 <a href=\"https://www.emqx.com/zh/cloud\">MQTT 云服务 - EMQX Cloud</a> 创建。服务器信息如下：</p>\n<blockquote>\n<p>Server: <code>broker.emqx.io</code></p>\n<p>TCP Port: <code>1883</code></p>\n<p>WebSocket Port: <code>8083</code></p>\n<p>SSL&#x2F;TLS Port: <code>8883</code></p>\n<p>Secure WebSocket Port: <code>8084</code></p>\n</blockquote>\n<h2 id=\"保留消息Retain\"><a href=\"#保留消息Retain\" class=\"headerlink\" title=\"保留消息Retain\"></a>保留消息Retain</h2><p>当 MQTT 客户端向服务器发布消息时，可以设置保留消息标志。保留消息存储在消息服务器上，后续订阅该主题的客户端仍然可以收到该消息。</p>\n<h2 id=\"clean-session\"><a href=\"#clean-session\" class=\"headerlink\" title=\"clean session\"></a>clean session</h2><p>如果客户端连接时设置 Clean Session 为 false，并且使用相同的客户端 ID 再次上线，那么消息服务器将为客户端缓存一定数量的离线消息，并在它重新上线时发送给它。</p>\n<h2 id=\"遗嘱消息Last-Will\"><a href=\"#遗嘱消息Last-Will\" class=\"headerlink\" title=\"遗嘱消息Last Will\"></a>遗嘱消息Last Will</h2><p>如果 MQTT 客户端异常离线（在断开连接前没有向服务器发送 DISCONNECT 消息），MQTT 服务器会发布遗嘱消息。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"模式\"><a href=\"#模式\" class=\"headerlink\" title=\"模式\"></a>模式</h2><p>mqtt是发布&#x2F;订阅的模式，客户端可以订阅感兴趣的主题，并接收与该主题相关的消息。</p>","more":"<h2 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h2><p>是中心分布，其他物联网设备连接到同一个服务端。每个物联网节点都可以作为一个发布者或者订阅者。发布者publish给服务器，订阅者subcribe从服务器。</p>\n<h2 id=\"消息结构\"><a href=\"#消息结构\" class=\"headerlink\" title=\"消息结构\"></a>消息结构</h2><ul>\n<li><p>topic，是一个字符串。当订阅者和发布者使用同名的topic时，它们之间就会自动构建连接。topic通过<code>/</code>来区分层级,如：<br><code>chat/room/1 sensor/10/temperature sensor/+/temperature</code></p>\n<p>MQTT  topic支持以下两种通配符：<code>+</code> 和 <code>#</code>。</p>\n<ul>\n<li><p><code>+</code>：表示单层通配符，例如 <code>a/+</code> 匹配 <code>a/x</code> 或 <code>a/y</code>。</p>\n</li>\n<li><p><code>#</code>：表示多层通配符，例如 <code>a/#</code> 匹配 <code>a/x</code>、<code>a/b/c/d</code>。</p>\n</li>\n</ul>\n<blockquote>\n<p><strong>注意</strong>：通配符主题只能用于订阅，不能用于发布。</p>\n</blockquote>\n</li>\n<li><p>payload，实际传输的内容，消息的主体部分。</p>\n</li>\n</ul>\n<h2 id=\"轻量化特性\"><a href=\"#轻量化特性\" class=\"headerlink\" title=\"轻量化特性\"></a>轻量化特性</h2><p>MQTT 开销低、报文小的特点使其非常适合物联网设备，因为它消耗更少的资源。</p>\n<h2 id=\"支持许多编程语言\"><a href=\"#支持许多编程语言\" class=\"headerlink\" title=\"支持许多编程语言\"></a>支持许多编程语言</h2><p>MQTT是一个开放的协议，因此获得了广泛的语言支持。</p>\n<h2 id=\"broker\"><a href=\"#broker\" class=\"headerlink\" title=\"broker\"></a>broker</h2><p>MQTT Broker 是负责处理客户端请求的关键组件，包括建立连接、断开连接、订阅和取消订阅等操作，同时还负责消息的转发。</p>\n<h2 id=\"QoS-服务质量\"><a href=\"#QoS-服务质量\" class=\"headerlink\" title=\"QoS(服务质量)\"></a>QoS(服务质量)</h2><p>mqtt提供了三种服务质量，在不同网络环境下保证消息的可靠性。</p>\n<ul>\n<li>QoS 0：消息最多传送一次。如果当前客户端不可用，它将丢失这条消息。</li>\n<li>QoS 1：消息至少传送一次。</li>\n<li>QoS 2：消息只传送一次。</li>\n</ul>\n<h2 id=\"基本工作流程\"><a href=\"#基本工作流程\" class=\"headerlink\" title=\"基本工作流程\"></a>基本工作流程</h2><ol>\n<li>客户端使用TCP&#x2F;IP协议与broke建立连接，可选TLS&#x2F;SSL加密。</li>\n<li>客户端可以向特定topic发布消息，也可订阅topic接收消息。</li>\n<li>broker接受发布的消息，并转发给订阅了对应topic的客户端。根据QoS等级确保消息可靠传递。</li>\n</ol>\n<h2 id=\"搭建mqtt-broker\"><a href=\"#搭建mqtt-broker\" class=\"headerlink\" title=\"搭建mqtt broker\"></a>搭建mqtt broker</h2><p>首先选择一个合适的MQTT服务器软件，这里推荐常用的EMQX。它适用于物联网、工业物联网和车联网。可以通过docker命令来安装emqx。</p>\n<pre><code class=\"docker\">docker run -d --name emqx -p 1883:1883 -p 8083:8083 -p 8084:8084 -p 8883:8883 -p 18083:18083 emqx/emqx\n</code></pre>\n<h2 id=\"mqtt客户端测试\"><a href=\"#mqtt客户端测试\" class=\"headerlink\" title=\"mqtt客户端测试\"></a>mqtt客户端测试</h2><p>推荐使用MQTTX，它可以方便地与Broker进行交互，提升开发和调试的效率。它可以快速创建链接保存并同时建立多个连接客户端。</p>\n<p>以下是一个<a href=\"https://www.emqx.com/zh/mqtt/public-mqtt5-broker\">免费公共 MQTT Broker</a>，它基于完全托管的 <a href=\"https://www.emqx.com/zh/cloud\">MQTT 云服务 - EMQX Cloud</a> 创建。服务器信息如下：</p>\n<blockquote>\n<p>Server: <code>broker.emqx.io</code></p>\n<p>TCP Port: <code>1883</code></p>\n<p>WebSocket Port: <code>8083</code></p>\n<p>SSL&#x2F;TLS Port: <code>8883</code></p>\n<p>Secure WebSocket Port: <code>8084</code></p>\n</blockquote>\n<h2 id=\"保留消息Retain\"><a href=\"#保留消息Retain\" class=\"headerlink\" title=\"保留消息Retain\"></a>保留消息Retain</h2><p>当 MQTT 客户端向服务器发布消息时，可以设置保留消息标志。保留消息存储在消息服务器上，后续订阅该主题的客户端仍然可以收到该消息。</p>\n<h2 id=\"clean-session\"><a href=\"#clean-session\" class=\"headerlink\" title=\"clean session\"></a>clean session</h2><p>如果客户端连接时设置 Clean Session 为 false，并且使用相同的客户端 ID 再次上线，那么消息服务器将为客户端缓存一定数量的离线消息，并在它重新上线时发送给它。</p>\n<h2 id=\"遗嘱消息Last-Will\"><a href=\"#遗嘱消息Last-Will\" class=\"headerlink\" title=\"遗嘱消息Last Will\"></a>遗嘱消息Last Will</h2><p>如果 MQTT 客户端异常离线（在断开连接前没有向服务器发送 DISCONNECT 消息），MQTT 服务器会发布遗嘱消息。</p>"},{"title":"git——分布式管理系统的入门与进阶（二）","date":"2023-10-31T05:38:55.000Z","_content":"\n### Git使用\n\n认识一下版本库——Repository，接下来我们所有提到的 Git 基础命令，都是基于版本库的。\n\n仓库，英文名 repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。\n\n<!--more-->\n\n#### 在已存在目录中初始化仓库 —— git init\n\n在已存在目录中创建一个版本库的过程非常简单：\n\n首先，选择一个合适的地方，创建一个空目录：\n\n**创建目录**\n\n\n\n```bash\n$ mkdir learning-git \n$ cd learning-git \n$ pwd /Users/xxm/learning-git\n```\n\n`pwd`命令用于显示当前目录。\n\n第二步，通过`git init`命令把这个目录变成 Git 可以管理的仓库：\n\n**初始化仓库**\n\n进入到要将目录变成仓库的路径，然后\n\n```bash \n$ git init \n```\n\n瞬间 Git 就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），同时在当前目录下多了一个`.git`的目录，这个目录是 Git 来跟踪管理版本库的，如果你没有看到 .git 目录，那是因为这个目录默认是隐藏的，用`ls -ah`命令就可以看到了。\n\n## 编辑并添加文件\n接下来，我们来尝试在已经准备好的 Git 仓库中创建一个readme.txt文件，内容如下：\n\n```bash Git is a version control system. Git is free software.```\n\n接下来，我们可以通过2个命令将刚创建好的readme.txt添加到Git仓库：\n\n第一步，用命令git add告诉 Git，把文件添加到仓库：\n\n```bash \n$ git add readme.txt\n```\n执行上面的命令，没有任何显示，说明添加成功。\n\n提交变动到仓库\n第二步，用命令git commit告诉 Git，把文件提交到仓库：\n\n```bash \n$ git commit -m \"随便写点说明wrote a readme file\" \n[master (root-commit) 50ed06b] \nwrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt\n```\n>这里简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。\n\ngit commit命令执行成功后会告诉你：\n\n- 1 file changed：1个文件被改动（我们新添加的readme.txt文件）\n- 2 insertions：插入了两行内容（readme.txt有两行内容）\n为什么 Git 添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：\n\n```bash \n$ git add file1.txt \n$ git add file2.txt file3.txt \n$ git commit -m \"这次一共add 3 files.\"\n```\n\n#### 查看Git仓库当前状态变化\n\n我们已经成功地添加并提交了一个`readme.txt`文件，接下来让我们继续修改`readme.txt`文件，改成如下内容：\n\n```\nbash Git is a distributed version control system. Git is free software.\n```\n>添加了“distributed”\n\n**查看 git status 结果**\n\n现在，运行`git status`命令看看结果：\n\n```bash \n\n$ git status \nOn branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory)\nmodified:   readme.txt\n```\n```\nno changes added to commit (use \"git add\" and/or \"git commit -a\") \n```\n\n`git status`命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，`readme.txt`被修改过了，但还没有准备提交的修改。\n\n#### 比较变动\n\n虽然 Git 告诉我们`readme.txt`被修改了，但并没有告诉我们具体修改的内容是什么，假如刚好是上周修改的，等到周一来班时，已经记不清上次怎么修改的`readme.txt`，这个时候我们就需要用`git diff`这个命令查看相较于上一次暂存都修改了些什么内容了：\n\n**运行 git diff 命令**\n\n\n\n```bash \n$ git diff \nreadme.txt \ndiff --git a/readme.txt b/readme.txt \nindex 46d49bf..9247db6 100644 \n--- a/readme.txt \n+++ b/readme.txt \n@@ -1,2 +1,2 @@ \n-Git is a version control system. \n+Git is a distributed version control system. Git is free software. (END)\n```\n\n`git diff`顾名思义就是查看 difference，显示的格式正是 Unix 通用的 `diff` 格式，可以从上面的输出看到，我们在第一行添加了一个`distributed`单词。\n\n#### 查看日志\n\ngit log可以查看全部的commit记录，如果嫌输出信息太多，看得眼花缭乱的，可以试试加上`--pretty=oneline`参数：\n\n**git log --pretty=oneline**\n\n## 克隆现有的仓库 —— git clone\n\n如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到 git clone 命令，Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。\n\n**git clone**\n\n\n当你执行`git clone` 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。\n\n克隆仓库的命令是 git clone <url>。 比如，要克隆 Git 的链接库 libgit2，可以用下面的命令：\n\n``` bash \n$ git clone https://gitcode.net/codechina/help-docs\n```\n\n这会在当前目录下创建一个名为 help-docs 的目录，并在这个目录下初始化一个 .git 文件夹， 从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 help-docs 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。\n\n**自定义本地仓库名称**\n\n当然如果你想在克隆远程仓库的时候，自定义本地仓库的名字也是可以的，你可以通过额外的参数指定新的目录名：\n\n``` bash \n$ git clone https://gitcode.net/codechina/help-docs mydocs\n```\n\n这会执行与上一条命令相同的操作，但目标目录名变为了` mydocs`。\n\nGit 支持多种数据传输协议。 上面的例子使用的是 https:// 协议，不过你也可以使用 git:// 协议或者使用 SSH 传输协议，比如 user@server:path/to/repo.git 。\n","source":"_posts/git——分布式管理系统的入门与进阶（二）.md","raw":"---\ntitle: git——分布式管理系统的入门与进阶（二）\ndate: 2023-10-31 13:38:55\ntags:\n- git\n- 分布式管理系统\ncategories: 版本控制系统\n---\n\n### Git使用\n\n认识一下版本库——Repository，接下来我们所有提到的 Git 基础命令，都是基于版本库的。\n\n仓库，英文名 repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。\n\n<!--more-->\n\n#### 在已存在目录中初始化仓库 —— git init\n\n在已存在目录中创建一个版本库的过程非常简单：\n\n首先，选择一个合适的地方，创建一个空目录：\n\n**创建目录**\n\n\n\n```bash\n$ mkdir learning-git \n$ cd learning-git \n$ pwd /Users/xxm/learning-git\n```\n\n`pwd`命令用于显示当前目录。\n\n第二步，通过`git init`命令把这个目录变成 Git 可以管理的仓库：\n\n**初始化仓库**\n\n进入到要将目录变成仓库的路径，然后\n\n```bash \n$ git init \n```\n\n瞬间 Git 就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），同时在当前目录下多了一个`.git`的目录，这个目录是 Git 来跟踪管理版本库的，如果你没有看到 .git 目录，那是因为这个目录默认是隐藏的，用`ls -ah`命令就可以看到了。\n\n## 编辑并添加文件\n接下来，我们来尝试在已经准备好的 Git 仓库中创建一个readme.txt文件，内容如下：\n\n```bash Git is a version control system. Git is free software.```\n\n接下来，我们可以通过2个命令将刚创建好的readme.txt添加到Git仓库：\n\n第一步，用命令git add告诉 Git，把文件添加到仓库：\n\n```bash \n$ git add readme.txt\n```\n执行上面的命令，没有任何显示，说明添加成功。\n\n提交变动到仓库\n第二步，用命令git commit告诉 Git，把文件提交到仓库：\n\n```bash \n$ git commit -m \"随便写点说明wrote a readme file\" \n[master (root-commit) 50ed06b] \nwrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt\n```\n>这里简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。\n\ngit commit命令执行成功后会告诉你：\n\n- 1 file changed：1个文件被改动（我们新添加的readme.txt文件）\n- 2 insertions：插入了两行内容（readme.txt有两行内容）\n为什么 Git 添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：\n\n```bash \n$ git add file1.txt \n$ git add file2.txt file3.txt \n$ git commit -m \"这次一共add 3 files.\"\n```\n\n#### 查看Git仓库当前状态变化\n\n我们已经成功地添加并提交了一个`readme.txt`文件，接下来让我们继续修改`readme.txt`文件，改成如下内容：\n\n```\nbash Git is a distributed version control system. Git is free software.\n```\n>添加了“distributed”\n\n**查看 git status 结果**\n\n现在，运行`git status`命令看看结果：\n\n```bash \n\n$ git status \nOn branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory)\nmodified:   readme.txt\n```\n```\nno changes added to commit (use \"git add\" and/or \"git commit -a\") \n```\n\n`git status`命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，`readme.txt`被修改过了，但还没有准备提交的修改。\n\n#### 比较变动\n\n虽然 Git 告诉我们`readme.txt`被修改了，但并没有告诉我们具体修改的内容是什么，假如刚好是上周修改的，等到周一来班时，已经记不清上次怎么修改的`readme.txt`，这个时候我们就需要用`git diff`这个命令查看相较于上一次暂存都修改了些什么内容了：\n\n**运行 git diff 命令**\n\n\n\n```bash \n$ git diff \nreadme.txt \ndiff --git a/readme.txt b/readme.txt \nindex 46d49bf..9247db6 100644 \n--- a/readme.txt \n+++ b/readme.txt \n@@ -1,2 +1,2 @@ \n-Git is a version control system. \n+Git is a distributed version control system. Git is free software. (END)\n```\n\n`git diff`顾名思义就是查看 difference，显示的格式正是 Unix 通用的 `diff` 格式，可以从上面的输出看到，我们在第一行添加了一个`distributed`单词。\n\n#### 查看日志\n\ngit log可以查看全部的commit记录，如果嫌输出信息太多，看得眼花缭乱的，可以试试加上`--pretty=oneline`参数：\n\n**git log --pretty=oneline**\n\n## 克隆现有的仓库 —— git clone\n\n如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到 git clone 命令，Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。\n\n**git clone**\n\n\n当你执行`git clone` 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。\n\n克隆仓库的命令是 git clone <url>。 比如，要克隆 Git 的链接库 libgit2，可以用下面的命令：\n\n``` bash \n$ git clone https://gitcode.net/codechina/help-docs\n```\n\n这会在当前目录下创建一个名为 help-docs 的目录，并在这个目录下初始化一个 .git 文件夹， 从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 help-docs 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。\n\n**自定义本地仓库名称**\n\n当然如果你想在克隆远程仓库的时候，自定义本地仓库的名字也是可以的，你可以通过额外的参数指定新的目录名：\n\n``` bash \n$ git clone https://gitcode.net/codechina/help-docs mydocs\n```\n\n这会执行与上一条命令相同的操作，但目标目录名变为了` mydocs`。\n\nGit 支持多种数据传输协议。 上面的例子使用的是 https:// 协议，不过你也可以使用 git:// 协议或者使用 SSH 传输协议，比如 user@server:path/to/repo.git 。\n","slug":"git——分布式管理系统的入门与进阶（二）","published":1,"updated":"2023-10-31T06:28:29.850Z","_id":"clodwlx5v0000a4vv8hczazi8","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"Git使用\"><a href=\"#Git使用\" class=\"headerlink\" title=\"Git使用\"></a>Git使用</h3><p>认识一下版本库——Repository，接下来我们所有提到的 Git 基础命令，都是基于版本库的。</p>\n<p>仓库，英文名 repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>\n<span id=\"more\"></span>\n\n<h4 id=\"在已存在目录中初始化仓库-——-git-init\"><a href=\"#在已存在目录中初始化仓库-——-git-init\" class=\"headerlink\" title=\"在已存在目录中初始化仓库 —— git init\"></a>在已存在目录中初始化仓库 —— git init</h4><p>在已存在目录中创建一个版本库的过程非常简单：</p>\n<p>首先，选择一个合适的地方，创建一个空目录：</p>\n<p><strong>创建目录</strong></p>\n<pre><code class=\"bash\">$ mkdir learning-git \n$ cd learning-git \n$ pwd /Users/xxm/learning-git\n</code></pre>\n<p><code>pwd</code>命令用于显示当前目录。</p>\n<p>第二步，通过<code>git init</code>命令把这个目录变成 Git 可以管理的仓库：</p>\n<p><strong>初始化仓库</strong></p>\n<p>进入到要将目录变成仓库的路径，然后</p>\n<pre><code class=\"bash\">$ git init \n</code></pre>\n<p>瞬间 Git 就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），同时在当前目录下多了一个<code>.git</code>的目录，这个目录是 Git 来跟踪管理版本库的，如果你没有看到 .git 目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看到了。</p>\n<h2 id=\"编辑并添加文件\"><a href=\"#编辑并添加文件\" class=\"headerlink\" title=\"编辑并添加文件\"></a>编辑并添加文件</h2><p>接下来，我们来尝试在已经准备好的 Git 仓库中创建一个readme.txt文件，内容如下：</p>\n<p><code>bash Git is a version control system. Git is free software.</code></p>\n<p>接下来，我们可以通过2个命令将刚创建好的readme.txt添加到Git仓库：</p>\n<p>第一步，用命令git add告诉 Git，把文件添加到仓库：</p>\n<pre><code class=\"bash\">$ git add readme.txt\n</code></pre>\n<p>执行上面的命令，没有任何显示，说明添加成功。</p>\n<p>提交变动到仓库<br>第二步，用命令git commit告诉 Git，把文件提交到仓库：</p>\n<pre><code class=\"bash\">$ git commit -m &quot;随便写点说明wrote a readme file&quot; \n[master (root-commit) 50ed06b] \nwrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt\n</code></pre>\n<blockquote>\n<p>这里简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>\n</blockquote>\n<p>git commit命令执行成功后会告诉你：</p>\n<ul>\n<li>1 file changed：1个文件被改动（我们新添加的readme.txt文件）</li>\n<li>2 insertions：插入了两行内容（readme.txt有两行内容）<br>为什么 Git 添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</li>\n</ul>\n<pre><code class=\"bash\">$ git add file1.txt \n$ git add file2.txt file3.txt \n$ git commit -m &quot;这次一共add 3 files.&quot;\n</code></pre>\n<h4 id=\"查看Git仓库当前状态变化\"><a href=\"#查看Git仓库当前状态变化\" class=\"headerlink\" title=\"查看Git仓库当前状态变化\"></a>查看Git仓库当前状态变化</h4><p>我们已经成功地添加并提交了一个<code>readme.txt</code>文件，接下来让我们继续修改<code>readme.txt</code>文件，改成如下内容：</p>\n<pre><code>bash Git is a distributed version control system. Git is free software.\n</code></pre>\n<blockquote>\n<p>添加了“distributed”</p>\n</blockquote>\n<p><strong>查看 git status 结果</strong></p>\n<p>现在，运行<code>git status</code>命令看看结果：</p>\n<pre><code class=\"bash\">\n$ git status \nOn branch master Changes not staged for commit: (use &quot;git add ...&quot; to update what will be committed) (use &quot;git checkout -- ...&quot; to discard changes in working directory)\nmodified:   readme.txt\n</code></pre>\n<pre><code>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) \n</code></pre>\n<p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p>\n<h4 id=\"比较变动\"><a href=\"#比较变动\" class=\"headerlink\" title=\"比较变动\"></a>比较变动</h4><p>虽然 Git 告诉我们<code>readme.txt</code>被修改了，但并没有告诉我们具体修改的内容是什么，假如刚好是上周修改的，等到周一来班时，已经记不清上次怎么修改的<code>readme.txt</code>，这个时候我们就需要用<code>git diff</code>这个命令查看相较于上一次暂存都修改了些什么内容了：</p>\n<p><strong>运行 git diff 命令</strong></p>\n<pre><code class=\"bash\">$ git diff \nreadme.txt \ndiff --git a/readme.txt b/readme.txt \nindex 46d49bf..9247db6 100644 \n--- a/readme.txt \n+++ b/readme.txt \n@@ -1,2 +1,2 @@ \n-Git is a version control system. \n+Git is a distributed version control system. Git is free software. (END)\n</code></pre>\n<p><code>git diff</code>顾名思义就是查看 difference，显示的格式正是 Unix 通用的 <code>diff</code> 格式，可以从上面的输出看到，我们在第一行添加了一个<code>distributed</code>单词。</p>\n<h4 id=\"查看日志\"><a href=\"#查看日志\" class=\"headerlink\" title=\"查看日志\"></a>查看日志</h4><p>git log可以查看全部的commit记录，如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p>\n<p><strong>git log –pretty&#x3D;oneline</strong></p>\n<h2 id=\"克隆现有的仓库-——-git-clone\"><a href=\"#克隆现有的仓库-——-git-clone\" class=\"headerlink\" title=\"克隆现有的仓库 —— git clone\"></a>克隆现有的仓库 —— git clone</h2><p>如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到 git clone 命令，Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。</p>\n<p><strong>git clone</strong></p>\n<p>当你执行<code>git clone</code> 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。</p>\n<p>克隆仓库的命令是 git clone <url>。 比如，要克隆 Git 的链接库 libgit2，可以用下面的命令：</p>\n<pre><code class=\"bash\">$ git clone https://gitcode.net/codechina/help-docs\n</code></pre>\n<p>这会在当前目录下创建一个名为 help-docs 的目录，并在这个目录下初始化一个 .git 文件夹， 从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 help-docs 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。</p>\n<p><strong>自定义本地仓库名称</strong></p>\n<p>当然如果你想在克隆远程仓库的时候，自定义本地仓库的名字也是可以的，你可以通过额外的参数指定新的目录名：</p>\n<pre><code class=\"bash\">$ git clone https://gitcode.net/codechina/help-docs mydocs\n</code></pre>\n<p>这会执行与上一条命令相同的操作，但目标目录名变为了<code> mydocs</code>。</p>\n<p>Git 支持多种数据传输协议。 上面的例子使用的是 https:&#x2F;&#x2F; 协议，不过你也可以使用 git:&#x2F;&#x2F; 协议或者使用 SSH 传输协议，比如 user@server:path&#x2F;to&#x2F;repo.git 。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"Git使用\"><a href=\"#Git使用\" class=\"headerlink\" title=\"Git使用\"></a>Git使用</h3><p>认识一下版本库——Repository，接下来我们所有提到的 Git 基础命令，都是基于版本库的。</p>\n<p>仓库，英文名 repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>","more":"<h4 id=\"在已存在目录中初始化仓库-——-git-init\"><a href=\"#在已存在目录中初始化仓库-——-git-init\" class=\"headerlink\" title=\"在已存在目录中初始化仓库 —— git init\"></a>在已存在目录中初始化仓库 —— git init</h4><p>在已存在目录中创建一个版本库的过程非常简单：</p>\n<p>首先，选择一个合适的地方，创建一个空目录：</p>\n<p><strong>创建目录</strong></p>\n<pre><code class=\"bash\">$ mkdir learning-git \n$ cd learning-git \n$ pwd /Users/xxm/learning-git\n</code></pre>\n<p><code>pwd</code>命令用于显示当前目录。</p>\n<p>第二步，通过<code>git init</code>命令把这个目录变成 Git 可以管理的仓库：</p>\n<p><strong>初始化仓库</strong></p>\n<p>进入到要将目录变成仓库的路径，然后</p>\n<pre><code class=\"bash\">$ git init \n</code></pre>\n<p>瞬间 Git 就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），同时在当前目录下多了一个<code>.git</code>的目录，这个目录是 Git 来跟踪管理版本库的，如果你没有看到 .git 目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看到了。</p>\n<h2 id=\"编辑并添加文件\"><a href=\"#编辑并添加文件\" class=\"headerlink\" title=\"编辑并添加文件\"></a>编辑并添加文件</h2><p>接下来，我们来尝试在已经准备好的 Git 仓库中创建一个readme.txt文件，内容如下：</p>\n<p><code>bash Git is a version control system. Git is free software.</code></p>\n<p>接下来，我们可以通过2个命令将刚创建好的readme.txt添加到Git仓库：</p>\n<p>第一步，用命令git add告诉 Git，把文件添加到仓库：</p>\n<pre><code class=\"bash\">$ git add readme.txt\n</code></pre>\n<p>执行上面的命令，没有任何显示，说明添加成功。</p>\n<p>提交变动到仓库<br>第二步，用命令git commit告诉 Git，把文件提交到仓库：</p>\n<pre><code class=\"bash\">$ git commit -m &quot;随便写点说明wrote a readme file&quot; \n[master (root-commit) 50ed06b] \nwrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt\n</code></pre>\n<blockquote>\n<p>这里简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>\n</blockquote>\n<p>git commit命令执行成功后会告诉你：</p>\n<ul>\n<li>1 file changed：1个文件被改动（我们新添加的readme.txt文件）</li>\n<li>2 insertions：插入了两行内容（readme.txt有两行内容）<br>为什么 Git 添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</li>\n</ul>\n<pre><code class=\"bash\">$ git add file1.txt \n$ git add file2.txt file3.txt \n$ git commit -m &quot;这次一共add 3 files.&quot;\n</code></pre>\n<h4 id=\"查看Git仓库当前状态变化\"><a href=\"#查看Git仓库当前状态变化\" class=\"headerlink\" title=\"查看Git仓库当前状态变化\"></a>查看Git仓库当前状态变化</h4><p>我们已经成功地添加并提交了一个<code>readme.txt</code>文件，接下来让我们继续修改<code>readme.txt</code>文件，改成如下内容：</p>\n<pre><code>bash Git is a distributed version control system. Git is free software.\n</code></pre>\n<blockquote>\n<p>添加了“distributed”</p>\n</blockquote>\n<p><strong>查看 git status 结果</strong></p>\n<p>现在，运行<code>git status</code>命令看看结果：</p>\n<pre><code class=\"bash\">\n$ git status \nOn branch master Changes not staged for commit: (use &quot;git add ...&quot; to update what will be committed) (use &quot;git checkout -- ...&quot; to discard changes in working directory)\nmodified:   readme.txt\n</code></pre>\n<pre><code>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) \n</code></pre>\n<p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p>\n<h4 id=\"比较变动\"><a href=\"#比较变动\" class=\"headerlink\" title=\"比较变动\"></a>比较变动</h4><p>虽然 Git 告诉我们<code>readme.txt</code>被修改了，但并没有告诉我们具体修改的内容是什么，假如刚好是上周修改的，等到周一来班时，已经记不清上次怎么修改的<code>readme.txt</code>，这个时候我们就需要用<code>git diff</code>这个命令查看相较于上一次暂存都修改了些什么内容了：</p>\n<p><strong>运行 git diff 命令</strong></p>\n<pre><code class=\"bash\">$ git diff \nreadme.txt \ndiff --git a/readme.txt b/readme.txt \nindex 46d49bf..9247db6 100644 \n--- a/readme.txt \n+++ b/readme.txt \n@@ -1,2 +1,2 @@ \n-Git is a version control system. \n+Git is a distributed version control system. Git is free software. (END)\n</code></pre>\n<p><code>git diff</code>顾名思义就是查看 difference，显示的格式正是 Unix 通用的 <code>diff</code> 格式，可以从上面的输出看到，我们在第一行添加了一个<code>distributed</code>单词。</p>\n<h4 id=\"查看日志\"><a href=\"#查看日志\" class=\"headerlink\" title=\"查看日志\"></a>查看日志</h4><p>git log可以查看全部的commit记录，如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p>\n<p><strong>git log –pretty&#x3D;oneline</strong></p>\n<h2 id=\"克隆现有的仓库-——-git-clone\"><a href=\"#克隆现有的仓库-——-git-clone\" class=\"headerlink\" title=\"克隆现有的仓库 —— git clone\"></a>克隆现有的仓库 —— git clone</h2><p>如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到 git clone 命令，Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。</p>\n<p><strong>git clone</strong></p>\n<p>当你执行<code>git clone</code> 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。</p>\n<p>克隆仓库的命令是 git clone <url>。 比如，要克隆 Git 的链接库 libgit2，可以用下面的命令：</p>\n<pre><code class=\"bash\">$ git clone https://gitcode.net/codechina/help-docs\n</code></pre>\n<p>这会在当前目录下创建一个名为 help-docs 的目录，并在这个目录下初始化一个 .git 文件夹， 从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 help-docs 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。</p>\n<p><strong>自定义本地仓库名称</strong></p>\n<p>当然如果你想在克隆远程仓库的时候，自定义本地仓库的名字也是可以的，你可以通过额外的参数指定新的目录名：</p>\n<pre><code class=\"bash\">$ git clone https://gitcode.net/codechina/help-docs mydocs\n</code></pre>\n<p>这会执行与上一条命令相同的操作，但目标目录名变为了<code> mydocs</code>。</p>\n<p>Git 支持多种数据传输协议。 上面的例子使用的是 https:&#x2F;&#x2F; 协议，不过你也可以使用 git:&#x2F;&#x2F; 协议或者使用 SSH 传输协议，比如 user@server:path&#x2F;to&#x2F;repo.git 。</p>"},{"title":"git——分布式管理系统的入门与进阶（一）","date":"2023-10-31T01:18:11.000Z","_content":"\n## 版本控制\n什么是“版本控制”？它究竟有什么作用？\n\n版本控制是一种系统，它记录了一个或者若干个内容变化，使得我们可以查阅各个版本的变化。\n\n<!--more-->\n\n有很多人会认为，只有源代码文件需要用到版本控制，但其实，你可以对任何类型的文件进行版本控制。\n\n有了版本控制系统，我们就可以将项目或是某个文件回溯到过去某个时间点的状态，可以通过比较文件的变化细节。查出最后是谁的修改导致出现的问题。使用版本控制系统意味着，即使你将所有文件乱删乱改一气，也可以轻松恢复它之前的样子。\n\n## 版本控制的发展历史\n- 本地版本控制系统：其中一种为RCS (Revision control system)，在硬盘上保存补丁集，通过应用所有补丁可以计算出各个版本的文件内容。*目前RCS由GNU工程师维护*\n\n- 集中化版本控制系统(Centralized Version Control Systems)：诸如CVS、Subversion以及Perforce，有一个集中管理的服务器，保存所有文件的修订版本。缺点是中心服务器单点故障会导致谁都无法使用，服务器的磁盘损坏时也会导致丢失项目的所有数据。\n\n- 分布式版本控制系统(Distributed Version Control System)：Git即为其中一员。客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 每一次的克隆操作，实际上都是一次对代码仓库的完整备份。\n## 两周时间，完成Git\n2005 年，Linux 系统的代码库之大已经让 Linus 很难继续手工管理了。\n\n于是，Linus 花了**两周**时间自己用 C 写了一个分布式版本控制系统，这就是 Git！一个月之内，Linux 系统的源码已经由 Git 管理了！\n<img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311011327.jpg\" alt=\"一个具有代表性的 git 会话，演示了存储库的初始化，以及文件和远程的添加。\" style=\"zoom:50%;\" />\n\n诞生以来，Git 日臻完善，2008年，GitHub 网站上线了，它为开源项目免费提供 Git 存储，无数开源项目开始迁移至 GitHub .\n\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Git-logo.svg/1920px-Git-logo.svg.png\" alt=\"定义\" style=\"zoom: 25%;\" />\n## 安装Git\n官方版本可以在 Git 官方网站下载。 打开 https://git-scm.com/download/win，然后选择相应的版本即可。 \n\n**git config**\n\nGit 自带一个 `git config` 的工具来帮助设置控制 Git 外观和行为的配置变量。\n\n接下来，我们先学习如何通过 `git config` 命令来配置 **用户信息**\n\n### 配置用户名和邮件地址 \n安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改： \n\n```bash \n$ git config --global  \"你的用户名\" \n$ git config --global user.email 你的邮箱 \n```\n再次强调，如果使用了 `--global` 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 > 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 `--global` 选项的命令来配置。\n\n如果想要检查你的配置，可以使用 `git config --list` 命令来列出所有 Git 当时能找到的配置。 \n\n你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：`/etc/gitconfig` 与 `~/.gitconfig`）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。 你可以通过输入 `git config ：` 来检查 Git 的某一项配置，例如： \n\n```bash \n$ git config user.name  \n```\n![Mona Lisa为作者设置的用户名，使用命令检查](https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311050837.jpg)\n## 更多Git 配置 \n\n### Git 颜色配置\n\n 到目前为止，我们已经配置了 `user.name` 和 `user.email` ，实际上，Git 还有很多可配置项。 比如，让 Git 显示颜色，会让命令输出看起来更醒目： \n ```bash\n $ git config --global color.ui true \n ```\n **Git 显示颜色**\n\n### Git忽略文件配置\n有些时候，你必须把某些文件放到 Git 工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件等等，每次`git status`都会显示`Untracked files ...`，这种情况下，就可以实用忽略特殊文件 `.gitignore` 来很方便的解决这个问题。 首先我们在 Git 工作区的根目录下创建一个特殊的 `.gitignore`文件，然后把要忽略的文件名填进去，Git 在每次进行提交的时候就会自动忽略这些文件。 \n\n ### Git 配置别名 \n除了通过 配置忽略文件 来提高`git commit` 时的便捷性外，Git 中还有一种可以让大家在敲入 Git 命令时偷懒的办法——那就是配置 Git 别名。 \n**配置 git status/commit/checkout/branch**\n比如在使用`git status`命令时，我们可以通过配置别名的方式将其配置为`git st`，这样在使用时是不是就比输入 `git status`简单方便很多呢？ 我们只需要敲一行命令，告诉 Git，以后`st`就表示`status`： ```bash $ git config --global alias.st status ``` 当然还有别的命令可以简写，很多人都用`co`表示`checkout`，`ci`表示`commit`，`br`表示`branch`： \n\n**配置别名**\n```bash \n$ git config --global alias.co checkout \n$ git config --global alias.ci commit \n$ git config --global alias.br branch \n```\n配置完成以上别名后，以后提交就可以简写成：\n```bash \n$ git ci -m \"sth.\" \n```\n`--global`参数是全局参数，也就是这些命令在这台电脑的所有 Git 仓库下都可以使用。 \n### 配置 git reset HEAD file \n再比如`git reset HEAD file`命令，他可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个`unstage`操作，就可以配置一个`unstage`别名： \n```bash \n$ git config --global alias.unstage 'reset HEAD' \n```\n当你敲入命令： \n```bash \n$ git unstage test.py \n```\n实际上 Git 执行的是： \n```bash \n$ git reset HEAD test.py \n```\n### 配置 git log -1 \n配置一个`git last`，让其显示最后一次提交信息： \n```bash \n$ git config --global alias.last 'log -1' \n```\n这样，用git last就能显示最近一次的提交：\n```bash \n$ git last \ncommit \n4aac6c7ee018f24d2dabfd01a1e09c77612e1a4e \n(HEAD -> master) \nAuthor: \nMiykael_xxm Date: \nTue Nov 17 11:14:15 2020 +0800 \nbranch test \n```\n### Git 配置文件\n这些自定义的Git配置文件通常都存放在仓库的`.git/config`文件中： \n**全局配置文件**\n\n```bash\n$ cat .git/config \n[core] \nrepositoryformatversion = 0 \nfilemode = true \nbare = false \nlogallrefupdates = true \nignorecase = true \nprecomposeunicode = true \n[remote \"origin\"] \nurl = git@codechina.csdn.net:codechina/learngit.git \nfetch = +refs/heads/*:refs/remotes/origin/* \n[branch \"master\"] \nremote = origin merge = refs/heads/master \n[alias] \nlast = log -1 \n```\n别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。 而当前用户的 Git 配置文件放在用户主目录下的一个隐藏文件`.gitconfig`中： \n**用户配置文件**\n\n```bash \n$ cat .gitconfig \n[alias] \nco = checkout \nci = commit \nbr = branch \nst = status \n[user] \nname = Your Name \nemail = your@email.com \n[color] \nui = true\n```\n配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。\n\n","source":"_posts/git入门与进阶（一）.md","raw":"---\ntitle: git——分布式管理系统的入门与进阶（一）\ndate: 2023-10-31 09:18:11\ntags:\n- git\n- 分布式管理系统\ncategories: 版本控制系统\n---\n\n## 版本控制\n什么是“版本控制”？它究竟有什么作用？\n\n版本控制是一种系统，它记录了一个或者若干个内容变化，使得我们可以查阅各个版本的变化。\n\n<!--more-->\n\n有很多人会认为，只有源代码文件需要用到版本控制，但其实，你可以对任何类型的文件进行版本控制。\n\n有了版本控制系统，我们就可以将项目或是某个文件回溯到过去某个时间点的状态，可以通过比较文件的变化细节。查出最后是谁的修改导致出现的问题。使用版本控制系统意味着，即使你将所有文件乱删乱改一气，也可以轻松恢复它之前的样子。\n\n## 版本控制的发展历史\n- 本地版本控制系统：其中一种为RCS (Revision control system)，在硬盘上保存补丁集，通过应用所有补丁可以计算出各个版本的文件内容。*目前RCS由GNU工程师维护*\n\n- 集中化版本控制系统(Centralized Version Control Systems)：诸如CVS、Subversion以及Perforce，有一个集中管理的服务器，保存所有文件的修订版本。缺点是中心服务器单点故障会导致谁都无法使用，服务器的磁盘损坏时也会导致丢失项目的所有数据。\n\n- 分布式版本控制系统(Distributed Version Control System)：Git即为其中一员。客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 每一次的克隆操作，实际上都是一次对代码仓库的完整备份。\n## 两周时间，完成Git\n2005 年，Linux 系统的代码库之大已经让 Linus 很难继续手工管理了。\n\n于是，Linus 花了**两周**时间自己用 C 写了一个分布式版本控制系统，这就是 Git！一个月之内，Linux 系统的源码已经由 Git 管理了！\n<img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311011327.jpg\" alt=\"一个具有代表性的 git 会话，演示了存储库的初始化，以及文件和远程的添加。\" style=\"zoom:50%;\" />\n\n诞生以来，Git 日臻完善，2008年，GitHub 网站上线了，它为开源项目免费提供 Git 存储，无数开源项目开始迁移至 GitHub .\n\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Git-logo.svg/1920px-Git-logo.svg.png\" alt=\"定义\" style=\"zoom: 25%;\" />\n## 安装Git\n官方版本可以在 Git 官方网站下载。 打开 https://git-scm.com/download/win，然后选择相应的版本即可。 \n\n**git config**\n\nGit 自带一个 `git config` 的工具来帮助设置控制 Git 外观和行为的配置变量。\n\n接下来，我们先学习如何通过 `git config` 命令来配置 **用户信息**\n\n### 配置用户名和邮件地址 \n安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改： \n\n```bash \n$ git config --global  \"你的用户名\" \n$ git config --global user.email 你的邮箱 \n```\n再次强调，如果使用了 `--global` 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 > 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 `--global` 选项的命令来配置。\n\n如果想要检查你的配置，可以使用 `git config --list` 命令来列出所有 Git 当时能找到的配置。 \n\n你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：`/etc/gitconfig` 与 `~/.gitconfig`）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。 你可以通过输入 `git config ：` 来检查 Git 的某一项配置，例如： \n\n```bash \n$ git config user.name  \n```\n![Mona Lisa为作者设置的用户名，使用命令检查](https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311050837.jpg)\n## 更多Git 配置 \n\n### Git 颜色配置\n\n 到目前为止，我们已经配置了 `user.name` 和 `user.email` ，实际上，Git 还有很多可配置项。 比如，让 Git 显示颜色，会让命令输出看起来更醒目： \n ```bash\n $ git config --global color.ui true \n ```\n **Git 显示颜色**\n\n### Git忽略文件配置\n有些时候，你必须把某些文件放到 Git 工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件等等，每次`git status`都会显示`Untracked files ...`，这种情况下，就可以实用忽略特殊文件 `.gitignore` 来很方便的解决这个问题。 首先我们在 Git 工作区的根目录下创建一个特殊的 `.gitignore`文件，然后把要忽略的文件名填进去，Git 在每次进行提交的时候就会自动忽略这些文件。 \n\n ### Git 配置别名 \n除了通过 配置忽略文件 来提高`git commit` 时的便捷性外，Git 中还有一种可以让大家在敲入 Git 命令时偷懒的办法——那就是配置 Git 别名。 \n**配置 git status/commit/checkout/branch**\n比如在使用`git status`命令时，我们可以通过配置别名的方式将其配置为`git st`，这样在使用时是不是就比输入 `git status`简单方便很多呢？ 我们只需要敲一行命令，告诉 Git，以后`st`就表示`status`： ```bash $ git config --global alias.st status ``` 当然还有别的命令可以简写，很多人都用`co`表示`checkout`，`ci`表示`commit`，`br`表示`branch`： \n\n**配置别名**\n```bash \n$ git config --global alias.co checkout \n$ git config --global alias.ci commit \n$ git config --global alias.br branch \n```\n配置完成以上别名后，以后提交就可以简写成：\n```bash \n$ git ci -m \"sth.\" \n```\n`--global`参数是全局参数，也就是这些命令在这台电脑的所有 Git 仓库下都可以使用。 \n### 配置 git reset HEAD file \n再比如`git reset HEAD file`命令，他可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个`unstage`操作，就可以配置一个`unstage`别名： \n```bash \n$ git config --global alias.unstage 'reset HEAD' \n```\n当你敲入命令： \n```bash \n$ git unstage test.py \n```\n实际上 Git 执行的是： \n```bash \n$ git reset HEAD test.py \n```\n### 配置 git log -1 \n配置一个`git last`，让其显示最后一次提交信息： \n```bash \n$ git config --global alias.last 'log -1' \n```\n这样，用git last就能显示最近一次的提交：\n```bash \n$ git last \ncommit \n4aac6c7ee018f24d2dabfd01a1e09c77612e1a4e \n(HEAD -> master) \nAuthor: \nMiykael_xxm Date: \nTue Nov 17 11:14:15 2020 +0800 \nbranch test \n```\n### Git 配置文件\n这些自定义的Git配置文件通常都存放在仓库的`.git/config`文件中： \n**全局配置文件**\n\n```bash\n$ cat .git/config \n[core] \nrepositoryformatversion = 0 \nfilemode = true \nbare = false \nlogallrefupdates = true \nignorecase = true \nprecomposeunicode = true \n[remote \"origin\"] \nurl = git@codechina.csdn.net:codechina/learngit.git \nfetch = +refs/heads/*:refs/remotes/origin/* \n[branch \"master\"] \nremote = origin merge = refs/heads/master \n[alias] \nlast = log -1 \n```\n别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。 而当前用户的 Git 配置文件放在用户主目录下的一个隐藏文件`.gitconfig`中： \n**用户配置文件**\n\n```bash \n$ cat .gitconfig \n[alias] \nco = checkout \nci = commit \nbr = branch \nst = status \n[user] \nname = Your Name \nemail = your@email.com \n[color] \nui = true\n```\n配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。\n\n","slug":"git入门与进阶（一）","published":1,"updated":"2023-10-31T05:41:29.695Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clody83bn0000kkvv1r8rh74z","content":"<h2 id=\"版本控制\"><a href=\"#版本控制\" class=\"headerlink\" title=\"版本控制\"></a>版本控制</h2><p>什么是“版本控制”？它究竟有什么作用？</p>\n<p>版本控制是一种系统，它记录了一个或者若干个内容变化，使得我们可以查阅各个版本的变化。</p>\n<span id=\"more\"></span>\n\n<p>有很多人会认为，只有源代码文件需要用到版本控制，但其实，你可以对任何类型的文件进行版本控制。</p>\n<p>有了版本控制系统，我们就可以将项目或是某个文件回溯到过去某个时间点的状态，可以通过比较文件的变化细节。查出最后是谁的修改导致出现的问题。使用版本控制系统意味着，即使你将所有文件乱删乱改一气，也可以轻松恢复它之前的样子。</p>\n<h2 id=\"版本控制的发展历史\"><a href=\"#版本控制的发展历史\" class=\"headerlink\" title=\"版本控制的发展历史\"></a>版本控制的发展历史</h2><ul>\n<li><p>本地版本控制系统：其中一种为RCS (Revision control system)，在硬盘上保存补丁集，通过应用所有补丁可以计算出各个版本的文件内容。<em>目前RCS由GNU工程师维护</em></p>\n</li>\n<li><p>集中化版本控制系统(Centralized Version Control Systems)：诸如CVS、Subversion以及Perforce，有一个集中管理的服务器，保存所有文件的修订版本。缺点是中心服务器单点故障会导致谁都无法使用，服务器的磁盘损坏时也会导致丢失项目的所有数据。</p>\n</li>\n<li><p>分布式版本控制系统(Distributed Version Control System)：Git即为其中一员。客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p>\n</li>\n</ul>\n<h2 id=\"两周时间，完成Git\"><a href=\"#两周时间，完成Git\" class=\"headerlink\" title=\"两周时间，完成Git\"></a>两周时间，完成Git</h2><p>2005 年，Linux 系统的代码库之大已经让 Linus 很难继续手工管理了。</p>\n<p>于是，Linus 花了<strong>两周</strong>时间自己用 C 写了一个分布式版本控制系统，这就是 Git！一个月之内，Linux 系统的源码已经由 Git 管理了！<br><img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311011327.jpg\" alt=\"一个具有代表性的 git 会话，演示了存储库的初始化，以及文件和远程的添加。\" style=\"zoom:50%;\" /></p>\n<p>诞生以来，Git 日臻完善，2008年，GitHub 网站上线了，它为开源项目免费提供 Git 存储，无数开源项目开始迁移至 GitHub .</p>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Git-logo.svg/1920px-Git-logo.svg.png\" alt=\"定义\" style=\"zoom: 25%;\" />\n## 安装Git\n官方版本可以在 Git 官方网站下载。 打开 https://git-scm.com/download/win，然后选择相应的版本即可。 \n\n<p><strong>git config</strong></p>\n<p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。</p>\n<p>接下来，我们先学习如何通过 <code>git config</code> 命令来配置 <strong>用户信息</strong></p>\n<h3 id=\"配置用户名和邮件地址\"><a href=\"#配置用户名和邮件地址\" class=\"headerlink\" title=\"配置用户名和邮件地址\"></a>配置用户名和邮件地址</h3><p>安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改： </p>\n<pre><code class=\"bash\">$ git config --global  &quot;你的用户名&quot; \n$ git config --global user.email 你的邮箱 \n</code></pre>\n<p>再次强调，如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 &gt; 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code> 选项的命令来配置。</p>\n<p>如果想要检查你的配置，可以使用 <code>git config --list</code> 命令来列出所有 Git 当时能找到的配置。 </p>\n<p>你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：<code>/etc/gitconfig</code> 与 <code>~/.gitconfig</code>）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。 你可以通过输入 <code>git config ：</code> 来检查 Git 的某一项配置，例如： </p>\n<pre><code class=\"bash\">$ git config user.name  \n</code></pre>\n<p><img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311050837.jpg\" alt=\"Mona Lisa为作者设置的用户名，使用命令检查\"></p>\n<h2 id=\"更多Git-配置\"><a href=\"#更多Git-配置\" class=\"headerlink\" title=\"更多Git 配置\"></a>更多Git 配置</h2><h3 id=\"Git-颜色配置\"><a href=\"#Git-颜色配置\" class=\"headerlink\" title=\"Git 颜色配置\"></a>Git 颜色配置</h3><p> 到目前为止，我们已经配置了 <code>user.name</code> 和 <code>user.email</code> ，实际上，Git 还有很多可配置项。 比如，让 Git 显示颜色，会让命令输出看起来更醒目： </p>\n<pre><code class=\"bash\">$ git config --global color.ui true \n</code></pre>\n<p> <strong>Git 显示颜色</strong></p>\n<h3 id=\"Git忽略文件配置\"><a href=\"#Git忽略文件配置\" class=\"headerlink\" title=\"Git忽略文件配置\"></a>Git忽略文件配置</h3><p>有些时候，你必须把某些文件放到 Git 工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件等等，每次<code>git status</code>都会显示<code>Untracked files ...</code>，这种情况下，就可以实用忽略特殊文件 <code>.gitignore</code> 来很方便的解决这个问题。 首先我们在 Git 工作区的根目录下创建一个特殊的 <code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git 在每次进行提交的时候就会自动忽略这些文件。 </p>\n<h3 id=\"Git-配置别名\"><a href=\"#Git-配置别名\" class=\"headerlink\" title=\"Git 配置别名\"></a>Git 配置别名</h3><p>除了通过 配置忽略文件 来提高<code>git commit</code> 时的便捷性外，Git 中还有一种可以让大家在敲入 Git 命令时偷懒的办法——那就是配置 Git 别名。<br><strong>配置 git status&#x2F;commit&#x2F;checkout&#x2F;branch</strong><br>比如在使用<code>git status</code>命令时，我们可以通过配置别名的方式将其配置为<code>git st</code>，这样在使用时是不是就比输入 <code>git status</code>简单方便很多呢？ 我们只需要敲一行命令，告诉 Git，以后<code>st</code>就表示<code>status</code>： <code>bash $ git config --global alias.st status </code> 当然还有别的命令可以简写，很多人都用<code>co</code>表示<code>checkout</code>，<code>ci</code>表示<code>commit</code>，<code>br</code>表示<code>branch</code>： </p>\n<p><strong>配置别名</strong></p>\n<pre><code class=\"bash\">$ git config --global alias.co checkout \n$ git config --global alias.ci commit \n$ git config --global alias.br branch \n</code></pre>\n<p>配置完成以上别名后，以后提交就可以简写成：</p>\n<pre><code class=\"bash\">$ git ci -m &quot;sth.&quot; \n</code></pre>\n<p><code>--global</code>参数是全局参数，也就是这些命令在这台电脑的所有 Git 仓库下都可以使用。 </p>\n<h3 id=\"配置-git-reset-HEAD-file\"><a href=\"#配置-git-reset-HEAD-file\" class=\"headerlink\" title=\"配置 git reset HEAD file\"></a>配置 git reset HEAD file</h3><p>再比如<code>git reset HEAD file</code>命令，他可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个<code>unstage</code>操作，就可以配置一个<code>unstage</code>别名： </p>\n<pre><code class=\"bash\">$ git config --global alias.unstage &#39;reset HEAD&#39; \n</code></pre>\n<p>当你敲入命令： </p>\n<pre><code class=\"bash\">$ git unstage test.py \n</code></pre>\n<p>实际上 Git 执行的是： </p>\n<pre><code class=\"bash\">$ git reset HEAD test.py \n</code></pre>\n<h3 id=\"配置-git-log-1\"><a href=\"#配置-git-log-1\" class=\"headerlink\" title=\"配置 git log -1\"></a>配置 git log -1</h3><p>配置一个<code>git last</code>，让其显示最后一次提交信息： </p>\n<pre><code class=\"bash\">$ git config --global alias.last &#39;log -1&#39; \n</code></pre>\n<p>这样，用git last就能显示最近一次的提交：</p>\n<pre><code class=\"bash\">$ git last \ncommit \n4aac6c7ee018f24d2dabfd01a1e09c77612e1a4e \n(HEAD -&gt; master) \nAuthor: \nMiykael_xxm Date: \nTue Nov 17 11:14:15 2020 +0800 \nbranch test \n</code></pre>\n<h3 id=\"Git-配置文件\"><a href=\"#Git-配置文件\" class=\"headerlink\" title=\"Git 配置文件\"></a>Git 配置文件</h3><p>这些自定义的Git配置文件通常都存放在仓库的<code>.git/config</code>文件中：<br><strong>全局配置文件</strong></p>\n<pre><code class=\"bash\">$ cat .git/config \n[core] \nrepositoryformatversion = 0 \nfilemode = true \nbare = false \nlogallrefupdates = true \nignorecase = true \nprecomposeunicode = true \n[remote &quot;origin&quot;] \nurl = git@codechina.csdn.net:codechina/learngit.git \nfetch = +refs/heads/*:refs/remotes/origin/* \n[branch &quot;master&quot;] \nremote = origin merge = refs/heads/master \n[alias] \nlast = log -1 \n</code></pre>\n<p>别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。 而当前用户的 Git 配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中：<br><strong>用户配置文件</strong></p>\n<pre><code class=\"bash\">$ cat .gitconfig \n[alias] \nco = checkout \nci = commit \nbr = branch \nst = status \n[user] \nname = Your Name \nemail = your@email.com \n[color] \nui = true\n</code></pre>\n<p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"版本控制\"><a href=\"#版本控制\" class=\"headerlink\" title=\"版本控制\"></a>版本控制</h2><p>什么是“版本控制”？它究竟有什么作用？</p>\n<p>版本控制是一种系统，它记录了一个或者若干个内容变化，使得我们可以查阅各个版本的变化。</p>","more":"<p>有很多人会认为，只有源代码文件需要用到版本控制，但其实，你可以对任何类型的文件进行版本控制。</p>\n<p>有了版本控制系统，我们就可以将项目或是某个文件回溯到过去某个时间点的状态，可以通过比较文件的变化细节。查出最后是谁的修改导致出现的问题。使用版本控制系统意味着，即使你将所有文件乱删乱改一气，也可以轻松恢复它之前的样子。</p>\n<h2 id=\"版本控制的发展历史\"><a href=\"#版本控制的发展历史\" class=\"headerlink\" title=\"版本控制的发展历史\"></a>版本控制的发展历史</h2><ul>\n<li><p>本地版本控制系统：其中一种为RCS (Revision control system)，在硬盘上保存补丁集，通过应用所有补丁可以计算出各个版本的文件内容。<em>目前RCS由GNU工程师维护</em></p>\n</li>\n<li><p>集中化版本控制系统(Centralized Version Control Systems)：诸如CVS、Subversion以及Perforce，有一个集中管理的服务器，保存所有文件的修订版本。缺点是中心服务器单点故障会导致谁都无法使用，服务器的磁盘损坏时也会导致丢失项目的所有数据。</p>\n</li>\n<li><p>分布式版本控制系统(Distributed Version Control System)：Git即为其中一员。客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p>\n</li>\n</ul>\n<h2 id=\"两周时间，完成Git\"><a href=\"#两周时间，完成Git\" class=\"headerlink\" title=\"两周时间，完成Git\"></a>两周时间，完成Git</h2><p>2005 年，Linux 系统的代码库之大已经让 Linus 很难继续手工管理了。</p>\n<p>于是，Linus 花了<strong>两周</strong>时间自己用 C 写了一个分布式版本控制系统，这就是 Git！一个月之内，Linux 系统的源码已经由 Git 管理了！<br><img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311011327.jpg\" alt=\"一个具有代表性的 git 会话，演示了存储库的初始化，以及文件和远程的添加。\" style=\"zoom:50%;\" /></p>\n<p>诞生以来，Git 日臻完善，2008年，GitHub 网站上线了，它为开源项目免费提供 Git 存储，无数开源项目开始迁移至 GitHub .</p>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Git-logo.svg/1920px-Git-logo.svg.png\" alt=\"定义\" style=\"zoom: 25%;\" />\n## 安装Git\n官方版本可以在 Git 官方网站下载。 打开 https://git-scm.com/download/win，然后选择相应的版本即可。 \n\n<p><strong>git config</strong></p>\n<p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。</p>\n<p>接下来，我们先学习如何通过 <code>git config</code> 命令来配置 <strong>用户信息</strong></p>\n<h3 id=\"配置用户名和邮件地址\"><a href=\"#配置用户名和邮件地址\" class=\"headerlink\" title=\"配置用户名和邮件地址\"></a>配置用户名和邮件地址</h3><p>安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改： </p>\n<pre><code class=\"bash\">$ git config --global  &quot;你的用户名&quot; \n$ git config --global user.email 你的邮箱 \n</code></pre>\n<p>再次强调，如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 &gt; 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code> 选项的命令来配置。</p>\n<p>如果想要检查你的配置，可以使用 <code>git config --list</code> 命令来列出所有 Git 当时能找到的配置。 </p>\n<p>你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：<code>/etc/gitconfig</code> 与 <code>~/.gitconfig</code>）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。 你可以通过输入 <code>git config ：</code> 来检查 Git 的某一项配置，例如： </p>\n<pre><code class=\"bash\">$ git config user.name  \n</code></pre>\n<p><img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311050837.jpg\" alt=\"Mona Lisa为作者设置的用户名，使用命令检查\"></p>\n<h2 id=\"更多Git-配置\"><a href=\"#更多Git-配置\" class=\"headerlink\" title=\"更多Git 配置\"></a>更多Git 配置</h2><h3 id=\"Git-颜色配置\"><a href=\"#Git-颜色配置\" class=\"headerlink\" title=\"Git 颜色配置\"></a>Git 颜色配置</h3><p> 到目前为止，我们已经配置了 <code>user.name</code> 和 <code>user.email</code> ，实际上，Git 还有很多可配置项。 比如，让 Git 显示颜色，会让命令输出看起来更醒目： </p>\n<pre><code class=\"bash\">$ git config --global color.ui true \n</code></pre>\n<p> <strong>Git 显示颜色</strong></p>\n<h3 id=\"Git忽略文件配置\"><a href=\"#Git忽略文件配置\" class=\"headerlink\" title=\"Git忽略文件配置\"></a>Git忽略文件配置</h3><p>有些时候，你必须把某些文件放到 Git 工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件等等，每次<code>git status</code>都会显示<code>Untracked files ...</code>，这种情况下，就可以实用忽略特殊文件 <code>.gitignore</code> 来很方便的解决这个问题。 首先我们在 Git 工作区的根目录下创建一个特殊的 <code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git 在每次进行提交的时候就会自动忽略这些文件。 </p>\n<h3 id=\"Git-配置别名\"><a href=\"#Git-配置别名\" class=\"headerlink\" title=\"Git 配置别名\"></a>Git 配置别名</h3><p>除了通过 配置忽略文件 来提高<code>git commit</code> 时的便捷性外，Git 中还有一种可以让大家在敲入 Git 命令时偷懒的办法——那就是配置 Git 别名。<br><strong>配置 git status&#x2F;commit&#x2F;checkout&#x2F;branch</strong><br>比如在使用<code>git status</code>命令时，我们可以通过配置别名的方式将其配置为<code>git st</code>，这样在使用时是不是就比输入 <code>git status</code>简单方便很多呢？ 我们只需要敲一行命令，告诉 Git，以后<code>st</code>就表示<code>status</code>： <code>bash $ git config --global alias.st status </code> 当然还有别的命令可以简写，很多人都用<code>co</code>表示<code>checkout</code>，<code>ci</code>表示<code>commit</code>，<code>br</code>表示<code>branch</code>： </p>\n<p><strong>配置别名</strong></p>\n<pre><code class=\"bash\">$ git config --global alias.co checkout \n$ git config --global alias.ci commit \n$ git config --global alias.br branch \n</code></pre>\n<p>配置完成以上别名后，以后提交就可以简写成：</p>\n<pre><code class=\"bash\">$ git ci -m &quot;sth.&quot; \n</code></pre>\n<p><code>--global</code>参数是全局参数，也就是这些命令在这台电脑的所有 Git 仓库下都可以使用。 </p>\n<h3 id=\"配置-git-reset-HEAD-file\"><a href=\"#配置-git-reset-HEAD-file\" class=\"headerlink\" title=\"配置 git reset HEAD file\"></a>配置 git reset HEAD file</h3><p>再比如<code>git reset HEAD file</code>命令，他可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个<code>unstage</code>操作，就可以配置一个<code>unstage</code>别名： </p>\n<pre><code class=\"bash\">$ git config --global alias.unstage &#39;reset HEAD&#39; \n</code></pre>\n<p>当你敲入命令： </p>\n<pre><code class=\"bash\">$ git unstage test.py \n</code></pre>\n<p>实际上 Git 执行的是： </p>\n<pre><code class=\"bash\">$ git reset HEAD test.py \n</code></pre>\n<h3 id=\"配置-git-log-1\"><a href=\"#配置-git-log-1\" class=\"headerlink\" title=\"配置 git log -1\"></a>配置 git log -1</h3><p>配置一个<code>git last</code>，让其显示最后一次提交信息： </p>\n<pre><code class=\"bash\">$ git config --global alias.last &#39;log -1&#39; \n</code></pre>\n<p>这样，用git last就能显示最近一次的提交：</p>\n<pre><code class=\"bash\">$ git last \ncommit \n4aac6c7ee018f24d2dabfd01a1e09c77612e1a4e \n(HEAD -&gt; master) \nAuthor: \nMiykael_xxm Date: \nTue Nov 17 11:14:15 2020 +0800 \nbranch test \n</code></pre>\n<h3 id=\"Git-配置文件\"><a href=\"#Git-配置文件\" class=\"headerlink\" title=\"Git 配置文件\"></a>Git 配置文件</h3><p>这些自定义的Git配置文件通常都存放在仓库的<code>.git/config</code>文件中：<br><strong>全局配置文件</strong></p>\n<pre><code class=\"bash\">$ cat .git/config \n[core] \nrepositoryformatversion = 0 \nfilemode = true \nbare = false \nlogallrefupdates = true \nignorecase = true \nprecomposeunicode = true \n[remote &quot;origin&quot;] \nurl = git@codechina.csdn.net:codechina/learngit.git \nfetch = +refs/heads/*:refs/remotes/origin/* \n[branch &quot;master&quot;] \nremote = origin merge = refs/heads/master \n[alias] \nlast = log -1 \n</code></pre>\n<p>别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。 而当前用户的 Git 配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中：<br><strong>用户配置文件</strong></p>\n<pre><code class=\"bash\">$ cat .gitconfig \n[alias] \nco = checkout \nci = commit \nbr = branch \nst = status \n[user] \nname = Your Name \nemail = your@email.com \n[color] \nui = true\n</code></pre>\n<p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p>"},{"title":"git入门与进阶(四)","date":"2023-10-31T07:57:41.000Z","_content":"\nGit和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。\n\n<!--more-->\n\n#### 工作区（Working Directory）\n\n就是你在电脑里能看到的目录，比如我的`learning`文件夹就是一个工作区：*图片这里的路径Repository是我自己取得名字，和实际的Repository无关，不要混淆*\n\n![image-20231031164444194](https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311644225.png)\n\n#### 版本库（Repository）\n\n工作区有一个隐藏目录`.git`，这个不算工作区，而是Git的版本库。\n\nGit的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支`master`，以及指向`master`的一个指针叫`HEAD`。\n\n![git-repo](https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311647630.jpeg)\n\n![图片来源b站Geekhour](https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310312037413.png)\n\n分支和`HEAD`的概念我们以后再讲。\n\n前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：\n\n第一步是用`git add`把文件添加进去，实际上就是把文件修改添加到暂存区；\n\n第二步是用`git commit`提交更改，实际上就是把暂存区的所有内容提交到当前分支。\n\n因为我们创建Git版本库时，Git自动为我们创建了唯一一个`master`分支，所以，现在，`git commit`就是往`master`分支上提交更改。\n\n你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。\n\n俗话说，实践出真知。现在，我们再练习一遍，先对`readme.txt`做个修改，比如加上一行内容：\n\n```\nGit is a distributed version control system.\nGit is free software distributed under the GPL.\nGit has a mutable index called stage.\n```\n\n然后，在工作区新增一个`LICENSE`文本文件（内容随便写）。\n\n先用`git status`查看一下状态：\n\n```\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   readme.txt\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n\tLICENSE\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\nGit非常清楚地告诉我们，`readme.txt`被修改了，而`LICENSE`还从来没有被添加过，所以它的状态是`Untracked`。\n\n现在，使用两次命令`git add`，把`readme.txt`和`LICENSE`都添加后，用`git status`再查看一下：\n\n```\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n\tnew file:   LICENSE\n\tmodified:   readme.txt\n```\n\n现在，暂存区的状态就变成这样了：\n\n![git-stage](https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311708577.jpeg)\n\n所以，`git add`命令实际上就是把要提交的所有修改放到**暂存区（Stage）**，然后，执行`git commit`就可以一次性把暂存区的所有修改提交到分支。\n\n```\n$ git commit -m \"understand how stage works\"\n[master e43a48b] understand how stage works\n 2 files changed, 2 insertions(+)\n create mode 100644 LICENSE\n```\n\n一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：\n\n```\n$ git status\nOn branch master\nnothing to commit, working tree clean\n```\n\n现在版本库变成了这样，暂存区就没有任何内容了：\n\n![git-stage-after-commit](https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311709648.jpeg)\n","source":"_posts/git入门与进阶-四.md","raw":"---\ntitle: git入门与进阶(四)\ntags:\n  - git\n  - 分布式管理系统\n  - 工作区\n  - 暂存区\ncategories: 版本控制系统\ndate: 2023-10-31 15:57:41\n---\n\nGit和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。\n\n<!--more-->\n\n#### 工作区（Working Directory）\n\n就是你在电脑里能看到的目录，比如我的`learning`文件夹就是一个工作区：*图片这里的路径Repository是我自己取得名字，和实际的Repository无关，不要混淆*\n\n![image-20231031164444194](https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311644225.png)\n\n#### 版本库（Repository）\n\n工作区有一个隐藏目录`.git`，这个不算工作区，而是Git的版本库。\n\nGit的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支`master`，以及指向`master`的一个指针叫`HEAD`。\n\n![git-repo](https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311647630.jpeg)\n\n![图片来源b站Geekhour](https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310312037413.png)\n\n分支和`HEAD`的概念我们以后再讲。\n\n前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：\n\n第一步是用`git add`把文件添加进去，实际上就是把文件修改添加到暂存区；\n\n第二步是用`git commit`提交更改，实际上就是把暂存区的所有内容提交到当前分支。\n\n因为我们创建Git版本库时，Git自动为我们创建了唯一一个`master`分支，所以，现在，`git commit`就是往`master`分支上提交更改。\n\n你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。\n\n俗话说，实践出真知。现在，我们再练习一遍，先对`readme.txt`做个修改，比如加上一行内容：\n\n```\nGit is a distributed version control system.\nGit is free software distributed under the GPL.\nGit has a mutable index called stage.\n```\n\n然后，在工作区新增一个`LICENSE`文本文件（内容随便写）。\n\n先用`git status`查看一下状态：\n\n```\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   readme.txt\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n\tLICENSE\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\nGit非常清楚地告诉我们，`readme.txt`被修改了，而`LICENSE`还从来没有被添加过，所以它的状态是`Untracked`。\n\n现在，使用两次命令`git add`，把`readme.txt`和`LICENSE`都添加后，用`git status`再查看一下：\n\n```\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n\tnew file:   LICENSE\n\tmodified:   readme.txt\n```\n\n现在，暂存区的状态就变成这样了：\n\n![git-stage](https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311708577.jpeg)\n\n所以，`git add`命令实际上就是把要提交的所有修改放到**暂存区（Stage）**，然后，执行`git commit`就可以一次性把暂存区的所有修改提交到分支。\n\n```\n$ git commit -m \"understand how stage works\"\n[master e43a48b] understand how stage works\n 2 files changed, 2 insertions(+)\n create mode 100644 LICENSE\n```\n\n一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：\n\n```\n$ git status\nOn branch master\nnothing to commit, working tree clean\n```\n\n现在版本库变成了这样，暂存区就没有任何内容了：\n\n![git-stage-after-commit](https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311709648.jpeg)\n","slug":"git入门与进阶-四","published":1,"updated":"2023-10-31T12:38:31.830Z","_id":"cloe2ngxb0000iovv43lychy7","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p>\n<span id=\"more\"></span>\n\n<h4 id=\"工作区（Working-Directory）\"><a href=\"#工作区（Working-Directory）\" class=\"headerlink\" title=\"工作区（Working Directory）\"></a>工作区（Working Directory）</h4><p>就是你在电脑里能看到的目录，比如我的<code>learning</code>文件夹就是一个工作区：<em>图片这里的路径Repository是我自己取得名字，和实际的Repository无关，不要混淆</em></p>\n<p><img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311644225.png\" alt=\"image-20231031164444194\"></p>\n<h4 id=\"版本库（Repository）\"><a href=\"#版本库（Repository）\" class=\"headerlink\" title=\"版本库（Repository）\"></a>版本库（Repository）</h4><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p>\n<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p>\n<p><img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311647630.jpeg\" alt=\"git-repo\"></p>\n<p><img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310312037413.png\" alt=\"图片来源b站Geekhour\"></p>\n<p>分支和<code>HEAD</code>的概念我们以后再讲。</p>\n<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>\n<p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p>\n<p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>\n<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p>\n<p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>\n<p>俗话说，实践出真知。现在，我们再练习一遍，先对<code>readme.txt</code>做个修改，比如加上一行内容：</p>\n<pre><code>Git is a distributed version control system.\nGit is free software distributed under the GPL.\nGit has a mutable index called stage.\n</code></pre>\n<p>然后，在工作区新增一个<code>LICENSE</code>文本文件（内容随便写）。</p>\n<p>先用<code>git status</code>查看一下状态：</p>\n<pre><code>$ git status\nOn branch master\nChanges not staged for commit:\n  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)\n  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)\n\n    modified:   readme.txt\n\nUntracked files:\n  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)\n\n    LICENSE\n\nno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)\n</code></pre>\n<p>Git非常清楚地告诉我们，<code>readme.txt</code>被修改了，而<code>LICENSE</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p>\n<p>现在，使用两次命令<code>git add</code>，把<code>readme.txt</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p>\n<pre><code>$ git status\nOn branch master\nChanges to be committed:\n  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)\n\n    new file:   LICENSE\n    modified:   readme.txt\n</code></pre>\n<p>现在，暂存区的状态就变成这样了：</p>\n<p><img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311708577.jpeg\" alt=\"git-stage\"></p>\n<p>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到<strong>暂存区（Stage）</strong>，然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p>\n<pre><code>$ git commit -m &quot;understand how stage works&quot;\n[master e43a48b] understand how stage works\n 2 files changed, 2 insertions(+)\n create mode 100644 LICENSE\n</code></pre>\n<p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p>\n<pre><code>$ git status\nOn branch master\nnothing to commit, working tree clean\n</code></pre>\n<p>现在版本库变成了这样，暂存区就没有任何内容了：</p>\n<p><img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311709648.jpeg\" alt=\"git-stage-after-commit\"></p>\n","site":{"data":{}},"excerpt":"<p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p>","more":"<h4 id=\"工作区（Working-Directory）\"><a href=\"#工作区（Working-Directory）\" class=\"headerlink\" title=\"工作区（Working Directory）\"></a>工作区（Working Directory）</h4><p>就是你在电脑里能看到的目录，比如我的<code>learning</code>文件夹就是一个工作区：<em>图片这里的路径Repository是我自己取得名字，和实际的Repository无关，不要混淆</em></p>\n<p><img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311644225.png\" alt=\"image-20231031164444194\"></p>\n<h4 id=\"版本库（Repository）\"><a href=\"#版本库（Repository）\" class=\"headerlink\" title=\"版本库（Repository）\"></a>版本库（Repository）</h4><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p>\n<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p>\n<p><img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311647630.jpeg\" alt=\"git-repo\"></p>\n<p><img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310312037413.png\" alt=\"图片来源b站Geekhour\"></p>\n<p>分支和<code>HEAD</code>的概念我们以后再讲。</p>\n<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>\n<p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p>\n<p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>\n<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p>\n<p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>\n<p>俗话说，实践出真知。现在，我们再练习一遍，先对<code>readme.txt</code>做个修改，比如加上一行内容：</p>\n<pre><code>Git is a distributed version control system.\nGit is free software distributed under the GPL.\nGit has a mutable index called stage.\n</code></pre>\n<p>然后，在工作区新增一个<code>LICENSE</code>文本文件（内容随便写）。</p>\n<p>先用<code>git status</code>查看一下状态：</p>\n<pre><code>$ git status\nOn branch master\nChanges not staged for commit:\n  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)\n  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)\n\n    modified:   readme.txt\n\nUntracked files:\n  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)\n\n    LICENSE\n\nno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)\n</code></pre>\n<p>Git非常清楚地告诉我们，<code>readme.txt</code>被修改了，而<code>LICENSE</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p>\n<p>现在，使用两次命令<code>git add</code>，把<code>readme.txt</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p>\n<pre><code>$ git status\nOn branch master\nChanges to be committed:\n  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)\n\n    new file:   LICENSE\n    modified:   readme.txt\n</code></pre>\n<p>现在，暂存区的状态就变成这样了：</p>\n<p><img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311708577.jpeg\" alt=\"git-stage\"></p>\n<p>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到<strong>暂存区（Stage）</strong>，然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p>\n<pre><code>$ git commit -m &quot;understand how stage works&quot;\n[master e43a48b] understand how stage works\n 2 files changed, 2 insertions(+)\n create mode 100644 LICENSE\n</code></pre>\n<p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p>\n<pre><code>$ git status\nOn branch master\nnothing to commit, working tree clean\n</code></pre>\n<p>现在版本库变成了这样，暂存区就没有任何内容了：</p>\n<p><img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311709648.jpeg\" alt=\"git-stage-after-commit\"></p>"},{"title":"git入门与进阶（三）","date":"2023-10-31T07:44:27.000Z","_content":"\n## 版本回退\n\n> 游戏里的save和load，git也能做到\n\n<!--more-->\n\n现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：\n\n```\nGit is a distributed version control system.\nGit is free software distributed under the GPL.\n```\n\n然后尝试提交：\n\n```\n$ git add readme.txt\n$ git commit -m \"append GPL\"\n[master 1094adb] append GPL\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\n像这样，你不断修改文件，然后不断提交修改到版本库里，就好比游戏中的存档，打不过可以load重来。Git也是一样，每当你觉得文件需要一个“存档”时，就可以“保存一个快照”，这个快照在Git中被称为`commit`（类比成游戏的存档点）。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个`commit`恢复，然后继续工作，而不是把几个月的工作成果全部丢失。\n\n版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用上一章提到的`git log`命令查看，你会看见每个commit后面都有一串乱码，这就是版本号。\n\n![image-20231031161459899](https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311614958.png)\n\n由于Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。所以commit后面的这串乱码其实就是SHA1计算出来的一个非常大的16进制数，可以防止版本号冲突。\n\n好了，现在我们启动时光穿梭机，准备把`readme.txt`回退到上一个版本，也就是`add a readme`的那个版本，怎么做呢？\n\n首先，Git必须知道当前版本是哪个版本，在Git中，用`HEAD`表示当前版本，也就是最新的提交`f22c...`（注意我的提交ID和你的肯定不一样），上一个版本就是`HEAD^`，上上一个版本就是`HEAD^^`，当然往上100个版本写100个`^`比较容易数不过来，所以写成`HEAD~100`。\n\n现在，我们要把当前版本`append GPL`回退到上一个版本`add a readme`\n\n就可以使用`git reset`命令(--hard参数的意义之后会讲，这里可以直接用)：\n\n```\n$ git reset --hard HEAD^\nHEAD is now at 05b0d73 add a readme\n```\n\n![image-20231031161735214](https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311617241.png)\n\n看看`readme.txt`的内容,已经被还原了（读档了）。\n\n此时再使用git log，会发现新版本append GPL已经消失了。怎么办？\n\n只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个`append GPL`的`commit id`是`f22c2...`，于是就可以指定回到未来的某个版本：\n\n依然还是`git reset --hard`只不过这次后面加的是版本号（不必写全版本号，取前几位，git会自动寻找），如下：\n`$ git reset --hard f22c2`\n运行完后再次查看readme.txt，果然，又找回了最新版本append GPL。\n\n## 查看历史\n现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？\n\n在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog记录了你的每次命令。\n在这里给读者留下一个作业，使用git reflog命令找到之前的最新版本号，并恢复到最新版本。\n\n","source":"_posts/git入门与进阶（三）.md","raw":"---\ntitle: git入门与进阶（三）\ndate: 2023-10-31 15:44:27\ntags:\n- git\n- 分布式管理系统\ncategories: 版本控制系统\n---\n\n## 版本回退\n\n> 游戏里的save和load，git也能做到\n\n<!--more-->\n\n现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：\n\n```\nGit is a distributed version control system.\nGit is free software distributed under the GPL.\n```\n\n然后尝试提交：\n\n```\n$ git add readme.txt\n$ git commit -m \"append GPL\"\n[master 1094adb] append GPL\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\n像这样，你不断修改文件，然后不断提交修改到版本库里，就好比游戏中的存档，打不过可以load重来。Git也是一样，每当你觉得文件需要一个“存档”时，就可以“保存一个快照”，这个快照在Git中被称为`commit`（类比成游戏的存档点）。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个`commit`恢复，然后继续工作，而不是把几个月的工作成果全部丢失。\n\n版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用上一章提到的`git log`命令查看，你会看见每个commit后面都有一串乱码，这就是版本号。\n\n![image-20231031161459899](https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311614958.png)\n\n由于Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。所以commit后面的这串乱码其实就是SHA1计算出来的一个非常大的16进制数，可以防止版本号冲突。\n\n好了，现在我们启动时光穿梭机，准备把`readme.txt`回退到上一个版本，也就是`add a readme`的那个版本，怎么做呢？\n\n首先，Git必须知道当前版本是哪个版本，在Git中，用`HEAD`表示当前版本，也就是最新的提交`f22c...`（注意我的提交ID和你的肯定不一样），上一个版本就是`HEAD^`，上上一个版本就是`HEAD^^`，当然往上100个版本写100个`^`比较容易数不过来，所以写成`HEAD~100`。\n\n现在，我们要把当前版本`append GPL`回退到上一个版本`add a readme`\n\n就可以使用`git reset`命令(--hard参数的意义之后会讲，这里可以直接用)：\n\n```\n$ git reset --hard HEAD^\nHEAD is now at 05b0d73 add a readme\n```\n\n![image-20231031161735214](https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311617241.png)\n\n看看`readme.txt`的内容,已经被还原了（读档了）。\n\n此时再使用git log，会发现新版本append GPL已经消失了。怎么办？\n\n只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个`append GPL`的`commit id`是`f22c2...`，于是就可以指定回到未来的某个版本：\n\n依然还是`git reset --hard`只不过这次后面加的是版本号（不必写全版本号，取前几位，git会自动寻找），如下：\n`$ git reset --hard f22c2`\n运行完后再次查看readme.txt，果然，又找回了最新版本append GPL。\n\n## 查看历史\n现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？\n\n在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog记录了你的每次命令。\n在这里给读者留下一个作业，使用git reflog命令找到之前的最新版本号，并恢复到最新版本。\n\n","slug":"git入门与进阶（三）","published":1,"updated":"2023-10-31T08:33:12.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloe2ngxk0004iovv8cxxf0h3","content":"<h2 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h2><blockquote>\n<p>游戏里的save和load，git也能做到</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：</p>\n<pre><code>Git is a distributed version control system.\nGit is free software distributed under the GPL.\n</code></pre>\n<p>然后尝试提交：</p>\n<pre><code>$ git add readme.txt\n$ git commit -m &quot;append GPL&quot;\n[master 1094adb] append GPL\n 1 file changed, 1 insertion(+), 1 deletion(-)\n</code></pre>\n<p>像这样，你不断修改文件，然后不断提交修改到版本库里，就好比游戏中的存档，打不过可以load重来。Git也是一样，每当你觉得文件需要一个“存档”时，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>（类比成游戏的存档点）。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>\n<p>版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用上一章提到的<code>git log</code>命令查看，你会看见每个commit后面都有一串乱码，这就是版本号。</p>\n<p><img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311614958.png\" alt=\"image-20231031161459899\"></p>\n<p>由于Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。所以commit后面的这串乱码其实就是SHA1计算出来的一个非常大的16进制数，可以防止版本号冲突。</p>\n<p>好了，现在我们启动时光穿梭机，准备把<code>readme.txt</code>回退到上一个版本，也就是<code>add a readme</code>的那个版本，怎么做呢？</p>\n<p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>f22c...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p>\n<p>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add a readme</code></p>\n<p>就可以使用<code>git reset</code>命令(–hard参数的意义之后会讲，这里可以直接用)：</p>\n<pre><code>$ git reset --hard HEAD^\nHEAD is now at 05b0d73 add a readme\n</code></pre>\n<p><img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311617241.png\" alt=\"image-20231031161735214\"></p>\n<p>看看<code>readme.txt</code>的内容,已经被还原了（读档了）。</p>\n<p>此时再使用git log，会发现新版本append GPL已经消失了。怎么办？</p>\n<p>只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>f22c2...</code>，于是就可以指定回到未来的某个版本：</p>\n<p>依然还是<code>git reset --hard</code>只不过这次后面加的是版本号（不必写全版本号，取前几位，git会自动寻找），如下：<br><code>$ git reset --hard f22c2</code><br>运行完后再次查看readme.txt，果然，又找回了最新版本append GPL。</p>\n<h2 id=\"查看历史\"><a href=\"#查看历史\" class=\"headerlink\" title=\"查看历史\"></a>查看历史</h2><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？</p>\n<p>在Git中，总是有后悔药可以吃的。当你用$ git reset –hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog记录了你的每次命令。<br>在这里给读者留下一个作业，使用git reflog命令找到之前的最新版本号，并恢复到最新版本。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h2><blockquote>\n<p>游戏里的save和load，git也能做到</p>\n</blockquote>","more":"<p>现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：</p>\n<pre><code>Git is a distributed version control system.\nGit is free software distributed under the GPL.\n</code></pre>\n<p>然后尝试提交：</p>\n<pre><code>$ git add readme.txt\n$ git commit -m &quot;append GPL&quot;\n[master 1094adb] append GPL\n 1 file changed, 1 insertion(+), 1 deletion(-)\n</code></pre>\n<p>像这样，你不断修改文件，然后不断提交修改到版本库里，就好比游戏中的存档，打不过可以load重来。Git也是一样，每当你觉得文件需要一个“存档”时，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>（类比成游戏的存档点）。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>\n<p>版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用上一章提到的<code>git log</code>命令查看，你会看见每个commit后面都有一串乱码，这就是版本号。</p>\n<p><img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311614958.png\" alt=\"image-20231031161459899\"></p>\n<p>由于Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。所以commit后面的这串乱码其实就是SHA1计算出来的一个非常大的16进制数，可以防止版本号冲突。</p>\n<p>好了，现在我们启动时光穿梭机，准备把<code>readme.txt</code>回退到上一个版本，也就是<code>add a readme</code>的那个版本，怎么做呢？</p>\n<p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>f22c...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p>\n<p>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add a readme</code></p>\n<p>就可以使用<code>git reset</code>命令(–hard参数的意义之后会讲，这里可以直接用)：</p>\n<pre><code>$ git reset --hard HEAD^\nHEAD is now at 05b0d73 add a readme\n</code></pre>\n<p><img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202310311617241.png\" alt=\"image-20231031161735214\"></p>\n<p>看看<code>readme.txt</code>的内容,已经被还原了（读档了）。</p>\n<p>此时再使用git log，会发现新版本append GPL已经消失了。怎么办？</p>\n<p>只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>f22c2...</code>，于是就可以指定回到未来的某个版本：</p>\n<p>依然还是<code>git reset --hard</code>只不过这次后面加的是版本号（不必写全版本号，取前几位，git会自动寻找），如下：<br><code>$ git reset --hard f22c2</code><br>运行完后再次查看readme.txt，果然，又找回了最新版本append GPL。</p>\n<h2 id=\"查看历史\"><a href=\"#查看历史\" class=\"headerlink\" title=\"查看历史\"></a>查看历史</h2><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？</p>\n<p>在Git中，总是有后悔药可以吃的。当你用$ git reset –hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog记录了你的每次命令。<br>在这里给读者留下一个作业，使用git reflog命令找到之前的最新版本号，并恢复到最新版本。</p>"},{"title":"git入门与进阶（五）","date":"2023-10-31T12:52:41.000Z","_content":"\nGit管理的是修改，而不是文件。\n\n本章主要是做一个简单实验，请读者自己动手，以证明上面这句话。\n\n<!--more-->\n\n实验步骤：\n\n1. 对readme.txt做一个修改.\n2. git add readme.txt\n3. git status\n4. 对readme.txt添加一个修改。\n5. git commit -m \"git跟踪修改而不是文件\"\n6. git status再次查看状态\n\n做完上面的步骤后，你一定会提出一个疑问：\n\n咦，我~~黑切呢~~的第二次改动呢？\n\n怎么只有第一次的改动被提交？\n\n别激动，我们回顾一下操作过程：\n\n第一次修改 -> `git add` -> 第二次修改 -> `git commit`\n\n提交后，用`git diff HEAD -- readme.txt`命令可以查看工作区和版本库里面最新版本的区别。\n\n>`git diff HEAD -- readme.txt` 是一个查看“工作区”与“HEAD”指向的最新提交（commit）即仓库的最新分支之间差异的命令。如果您移除`HEAD`，命令会变成 `git diff -- readme.txt`，这将比较“工作区”和“暂存区”（Index）的差异，而不是与最新提交的差异。\n\n执行完后，你会发现第二次修改确实没有被提交。\n\n\n\n因为Git管理的是修改，当你用`git add`命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，`git commit`只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。\n\n聪明的你，此时应该已经想到怎么解决了。\n\n\n\n没错，你可以继续`git add`再`git commit`，也可以别着急提交第一次修改，先`git add`第二次修改，再`git commit`，就相当于把两次修改合并后一块提交了\n","source":"_posts/git5.md","raw":"---\ntitle: git入门与进阶（五）\ntags:\n  - git\n  - 分布式管理系统\n  - 管理修改\ncategories: 版本控制系统\ndate: 2023-10-31 20:52:41\n---\n\nGit管理的是修改，而不是文件。\n\n本章主要是做一个简单实验，请读者自己动手，以证明上面这句话。\n\n<!--more-->\n\n实验步骤：\n\n1. 对readme.txt做一个修改.\n2. git add readme.txt\n3. git status\n4. 对readme.txt添加一个修改。\n5. git commit -m \"git跟踪修改而不是文件\"\n6. git status再次查看状态\n\n做完上面的步骤后，你一定会提出一个疑问：\n\n咦，我~~黑切呢~~的第二次改动呢？\n\n怎么只有第一次的改动被提交？\n\n别激动，我们回顾一下操作过程：\n\n第一次修改 -> `git add` -> 第二次修改 -> `git commit`\n\n提交后，用`git diff HEAD -- readme.txt`命令可以查看工作区和版本库里面最新版本的区别。\n\n>`git diff HEAD -- readme.txt` 是一个查看“工作区”与“HEAD”指向的最新提交（commit）即仓库的最新分支之间差异的命令。如果您移除`HEAD`，命令会变成 `git diff -- readme.txt`，这将比较“工作区”和“暂存区”（Index）的差异，而不是与最新提交的差异。\n\n执行完后，你会发现第二次修改确实没有被提交。\n\n\n\n因为Git管理的是修改，当你用`git add`命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，`git commit`只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。\n\n聪明的你，此时应该已经想到怎么解决了。\n\n\n\n没错，你可以继续`git add`再`git commit`，也可以别着急提交第一次修改，先`git add`第二次修改，再`git commit`，就相当于把两次修改合并后一块提交了\n","slug":"git5","published":1,"updated":"2023-10-31T15:52:02.835Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloeibslq00007svv0vqh75bg","content":"<p>Git管理的是修改，而不是文件。</p>\n<p>本章主要是做一个简单实验，请读者自己动手，以证明上面这句话。</p>\n<span id=\"more\"></span>\n\n<p>实验步骤：</p>\n<ol>\n<li>对readme.txt做一个修改.</li>\n<li>git add readme.txt</li>\n<li>git status</li>\n<li>对readme.txt添加一个修改。</li>\n<li>git commit -m “git跟踪修改而不是文件”</li>\n<li>git status再次查看状态</li>\n</ol>\n<p>做完上面的步骤后，你一定会提出一个疑问：</p>\n<p>咦，我<del>黑切呢</del>的第二次改动呢？</p>\n<p>怎么只有第一次的改动被提交？</p>\n<p>别激动，我们回顾一下操作过程：</p>\n<p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p>\n<p>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别。</p>\n<blockquote>\n<p><code>git diff HEAD -- readme.txt</code> 是一个查看“工作区”与“HEAD”指向的最新提交（commit）即仓库的最新分支之间差异的命令。如果您移除<code>HEAD</code>，命令会变成 <code>git diff -- readme.txt</code>，这将比较“工作区”和“暂存区”（Index）的差异，而不是与最新提交的差异。</p>\n</blockquote>\n<p>执行完后，你会发现第二次修改确实没有被提交。</p>\n<p>因为Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>\n<p>聪明的你，此时应该已经想到怎么解决了。</p>\n<p>没错，你可以继续<code>git add</code>再<code>git commit</code>，也可以别着急提交第一次修改，先<code>git add</code>第二次修改，再<code>git commit</code>，就相当于把两次修改合并后一块提交了</p>\n","site":{"data":{}},"excerpt":"<p>Git管理的是修改，而不是文件。</p>\n<p>本章主要是做一个简单实验，请读者自己动手，以证明上面这句话。</p>","more":"<p>实验步骤：</p>\n<ol>\n<li>对readme.txt做一个修改.</li>\n<li>git add readme.txt</li>\n<li>git status</li>\n<li>对readme.txt添加一个修改。</li>\n<li>git commit -m “git跟踪修改而不是文件”</li>\n<li>git status再次查看状态</li>\n</ol>\n<p>做完上面的步骤后，你一定会提出一个疑问：</p>\n<p>咦，我<del>黑切呢</del>的第二次改动呢？</p>\n<p>怎么只有第一次的改动被提交？</p>\n<p>别激动，我们回顾一下操作过程：</p>\n<p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p>\n<p>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别。</p>\n<blockquote>\n<p><code>git diff HEAD -- readme.txt</code> 是一个查看“工作区”与“HEAD”指向的最新提交（commit）即仓库的最新分支之间差异的命令。如果您移除<code>HEAD</code>，命令会变成 <code>git diff -- readme.txt</code>，这将比较“工作区”和“暂存区”（Index）的差异，而不是与最新提交的差异。</p>\n</blockquote>\n<p>执行完后，你会发现第二次修改确实没有被提交。</p>\n<p>因为Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>\n<p>聪明的你，此时应该已经想到怎么解决了。</p>\n<p>没错，你可以继续<code>git add</code>再<code>git commit</code>，也可以别着急提交第一次修改，先<code>git add</code>第二次修改，再<code>git commit</code>，就相当于把两次修改合并后一块提交了</p>"},{"title":"git入门与进阶(六)","date":"2023-11-01T08:57:39.000Z","_content":"人非圣贤，都会犯错。现在Echo就闯了一个大祸，他不小心~~故意~~在`readme.txt`中添加了一行“我不想干活啦”。\n\n<!--more-->\n\n添加完后，还没有__add到暂存区__,echo就后悔了，因为老板很有可能帮助echo实现愿望。\n不过现在事情还不算糟。ECho使用git status查看状态~~有没有留下痕迹~~，\n\n![image-20231101202134867](https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202311012021917.png)\n\n可以看到git这里提示Echo使用“git restore”指令来丢弃工作区的更改。*老版本使用的则是checkout*\n\n很好，echo知道这个指令以后马上就去尝试了。\n\n他输入`git restore readme.txt`，回车。\n\n果然，readme的内容已经变回去了。git status也没发现未提交的更改。\n\n看来echo还可以继续在公司干一段时间。\n\n但是假如，另一个时空的echo，不仅将这段话加入到了readme中，还不小心把更改add到了暂存区中。\n\n万幸，还没**commit**。\n\necho~~又~~ 使用了git status。\n\n![image-20231101203831656](https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202311012038685.png)\n\n贴心的git又给出了小tip。\n\necho这回使用\n\n```bash\ngit restore --staged readme.txt\n```\n\n然后git status察看一下。\n\n嗯，这下又回到了上个宇宙的echo的情况了。虽然这个时空的echo还是一头雾水，但我们的读者全都知道，再使用一次git restore readme.txt就可以了。\n\n嗯，另另一个平行宇宙的echo，这回不仅**add**、还**commit**了，但他想起了**git 入门与进阶（五）**的内容，所以也无事发生。\n\n什么？另另另一个平行宇宙的echo，这回不仅**add**、**commit**了，还提交到了远程版本库！\n\n于是老板实现了echo不想工作的愿望。\n","source":"_posts/git入门与进阶-六.md","raw":"---\ntitle: git入门与进阶(六)\ntags:\n  - git\n  - 分布式管理系统\n  - 撤销修改\n  - 删除\ncategories: 版本控制系统\ndate: 2023-11-01 16:57:39\n---\n人非圣贤，都会犯错。现在Echo就闯了一个大祸，他不小心~~故意~~在`readme.txt`中添加了一行“我不想干活啦”。\n\n<!--more-->\n\n添加完后，还没有__add到暂存区__,echo就后悔了，因为老板很有可能帮助echo实现愿望。\n不过现在事情还不算糟。ECho使用git status查看状态~~有没有留下痕迹~~，\n\n![image-20231101202134867](https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202311012021917.png)\n\n可以看到git这里提示Echo使用“git restore”指令来丢弃工作区的更改。*老版本使用的则是checkout*\n\n很好，echo知道这个指令以后马上就去尝试了。\n\n他输入`git restore readme.txt`，回车。\n\n果然，readme的内容已经变回去了。git status也没发现未提交的更改。\n\n看来echo还可以继续在公司干一段时间。\n\n但是假如，另一个时空的echo，不仅将这段话加入到了readme中，还不小心把更改add到了暂存区中。\n\n万幸，还没**commit**。\n\necho~~又~~ 使用了git status。\n\n![image-20231101203831656](https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202311012038685.png)\n\n贴心的git又给出了小tip。\n\necho这回使用\n\n```bash\ngit restore --staged readme.txt\n```\n\n然后git status察看一下。\n\n嗯，这下又回到了上个宇宙的echo的情况了。虽然这个时空的echo还是一头雾水，但我们的读者全都知道，再使用一次git restore readme.txt就可以了。\n\n嗯，另另一个平行宇宙的echo，这回不仅**add**、还**commit**了，但他想起了**git 入门与进阶（五）**的内容，所以也无事发生。\n\n什么？另另另一个平行宇宙的echo，这回不仅**add**、**commit**了，还提交到了远程版本库！\n\n于是老板实现了echo不想工作的愿望。\n","slug":"git入门与进阶-六","published":1,"updated":"2023-11-01T12:49:59.439Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clofr9l8w0000mcvv5u6rbhg9","content":"<p>人非圣贤，都会犯错。现在Echo就闯了一个大祸，他不小心<del>故意</del>在<code>readme.txt</code>中添加了一行“我不想干活啦”。</p>\n<span id=\"more\"></span>\n\n<p>添加完后，还没有__add到暂存区__,echo就后悔了，因为老板很有可能帮助echo实现愿望。<br>不过现在事情还不算糟。ECho使用git status查看状态<del>有没有留下痕迹</del>，</p>\n<p><img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202311012021917.png\" alt=\"image-20231101202134867\"></p>\n<p>可以看到git这里提示Echo使用“git restore”指令来丢弃工作区的更改。<em>老版本使用的则是checkout</em></p>\n<p>很好，echo知道这个指令以后马上就去尝试了。</p>\n<p>他输入<code>git restore readme.txt</code>，回车。</p>\n<p>果然，readme的内容已经变回去了。git status也没发现未提交的更改。</p>\n<p>看来echo还可以继续在公司干一段时间。</p>\n<p>但是假如，另一个时空的echo，不仅将这段话加入到了readme中，还不小心把更改add到了暂存区中。</p>\n<p>万幸，还没<strong>commit</strong>。</p>\n<p>echo<del>又</del> 使用了git status。</p>\n<p><img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202311012038685.png\" alt=\"image-20231101203831656\"></p>\n<p>贴心的git又给出了小tip。</p>\n<p>echo这回使用</p>\n<pre><code class=\"bash\">git restore --staged readme.txt\n</code></pre>\n<p>然后git status察看一下。</p>\n<p>嗯，这下又回到了上个宇宙的echo的情况了。虽然这个时空的echo还是一头雾水，但我们的读者全都知道，再使用一次git restore readme.txt就可以了。</p>\n<p>嗯，另另一个平行宇宙的echo，这回不仅<strong>add</strong>、还<strong>commit</strong>了，但他想起了<strong>git 入门与进阶（五）</strong>的内容，所以也无事发生。</p>\n<p>什么？另另另一个平行宇宙的echo，这回不仅<strong>add</strong>、<strong>commit</strong>了，还提交到了远程版本库！</p>\n<p>于是老板实现了echo不想工作的愿望。</p>\n","site":{"data":{}},"excerpt":"<p>人非圣贤，都会犯错。现在Echo就闯了一个大祸，他不小心<del>故意</del>在<code>readme.txt</code>中添加了一行“我不想干活啦”。</p>","more":"<p>添加完后，还没有__add到暂存区__,echo就后悔了，因为老板很有可能帮助echo实现愿望。<br>不过现在事情还不算糟。ECho使用git status查看状态<del>有没有留下痕迹</del>，</p>\n<p><img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202311012021917.png\" alt=\"image-20231101202134867\"></p>\n<p>可以看到git这里提示Echo使用“git restore”指令来丢弃工作区的更改。<em>老版本使用的则是checkout</em></p>\n<p>很好，echo知道这个指令以后马上就去尝试了。</p>\n<p>他输入<code>git restore readme.txt</code>，回车。</p>\n<p>果然，readme的内容已经变回去了。git status也没发现未提交的更改。</p>\n<p>看来echo还可以继续在公司干一段时间。</p>\n<p>但是假如，另一个时空的echo，不仅将这段话加入到了readme中，还不小心把更改add到了暂存区中。</p>\n<p>万幸，还没<strong>commit</strong>。</p>\n<p>echo<del>又</del> 使用了git status。</p>\n<p><img src=\"https://echobox-1307380937.cos.ap-shanghai.myqcloud.com/echo/202311012038685.png\" alt=\"image-20231101203831656\"></p>\n<p>贴心的git又给出了小tip。</p>\n<p>echo这回使用</p>\n<pre><code class=\"bash\">git restore --staged readme.txt\n</code></pre>\n<p>然后git status察看一下。</p>\n<p>嗯，这下又回到了上个宇宙的echo的情况了。虽然这个时空的echo还是一头雾水，但我们的读者全都知道，再使用一次git restore readme.txt就可以了。</p>\n<p>嗯，另另一个平行宇宙的echo，这回不仅<strong>add</strong>、还<strong>commit</strong>了，但他想起了<strong>git 入门与进阶（五）</strong>的内容，所以也无事发生。</p>\n<p>什么？另另另一个平行宇宙的echo，这回不仅<strong>add</strong>、<strong>commit</strong>了，还提交到了远程版本库！</p>\n<p>于是老板实现了echo不想工作的愿望。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"clo3w9irx00018kvvfsnj1w29","category_id":"clo3w9is400048kvv3g324cpi","_id":"clo3w9isb000d8kvvg6b70bqx"},{"post_id":"clo3w9is200038kvveutze2sb","category_id":"clo3w9is9000a8kvv0o5cf0yj","_id":"clo3w9isb000g8kvv3v2chn35"},{"post_id":"clo3w9is600078kvv0gf92dhm","category_id":"clo3w9isb000e8kvv0mfqe9am","_id":"clo3w9isc000l8kvv3jtkaefs"},{"post_id":"clo3w9is800098kvv3en10had","category_id":"clo3w9isb000h8kvv7z921sqa","_id":"clo3w9isd000n8kvvd7tuar0p"},{"post_id":"clo4h74z20000c0vvdh5egppu","category_id":"clo4h74za0002c0vv46xc3owh","_id":"clo4h74zd0005c0vvcd614qdl"},{"post_id":"clo4h74z80001c0vvhc3z3b95","category_id":"clo4hcg920000g4vv1fi94t6o","_id":"clo4hcg950006g4vvffsuecnh"},{"post_id":"clo4h74z80001c0vvhc3z3b95","category_id":"clo4hcg940003g4vvaamv8htf","_id":"clo4hcg950007g4vvfi6b1sht"},{"post_id":"clod3x3d20000q4vv0w6g3v7t","category_id":"clod407i20001q4vv4qqva50y","_id":"clod407i30004q4vv249qdsg9"},{"post_id":"clodwlx5v0000a4vv8hczazi8","category_id":"clodrw1ri0001y4vv5ivm6j7j","_id":"clodwlx5w0003a4vv7wff566b"},{"post_id":"clody83bn0000kkvv1r8rh74z","category_id":"clodrw1ri0001y4vv5ivm6j7j","_id":"clody83bq0003kkvvcqz0bpy3"},{"post_id":"cloe2ngxb0000iovv43lychy7","category_id":"clodrw1ri0001y4vv5ivm6j7j","_id":"cloe2ngxg0003iovv149sapsj"},{"post_id":"cloe2ngxk0004iovv8cxxf0h3","category_id":"clodrw1ri0001y4vv5ivm6j7j","_id":"cloe2ngxn0007iovvda3rewvi"},{"post_id":"cloeibslq00007svv0vqh75bg","category_id":"clodrw1ri0001y4vv5ivm6j7j","_id":"cloeibslz00027svv1ehp3prg"},{"post_id":"clofr9l8w0000mcvv5u6rbhg9","category_id":"clodrw1ri0001y4vv5ivm6j7j","_id":"clofr9l940002mcvvfyso4v01"}],"PostTag":[{"post_id":"clo3w9irx00018kvvfsnj1w29","tag_id":"clo3w9is500058kvv10ry33sg","_id":"clo3w9isa000c8kvvev2eevir"},{"post_id":"clo3w9is200038kvveutze2sb","tag_id":"clo3w9isa000b8kvv0qqa4hyh","_id":"clo3w9isc000j8kvv7yna18o3"},{"post_id":"clo3w9is200038kvveutze2sb","tag_id":"clo3w9isb000f8kvvey682k93","_id":"clo3w9isc000k8kvvb2subj2q"},{"post_id":"clo3w9is600078kvv0gf92dhm","tag_id":"clo3w9isc000i8kvv89xlc67z","_id":"clo3w9isd000p8kvvbb75fg01"},{"post_id":"clo3w9is600078kvv0gf92dhm","tag_id":"clo3w9isc000m8kvvdf6t6c2h","_id":"clo3w9isd000q8kvvd8b96jp4"},{"post_id":"clo3w9is800098kvv3en10had","tag_id":"clo3w9isd000o8kvvfi655j36","_id":"clo3w9ise000s8kvv7sht5g7b"},{"post_id":"clo3w9is800098kvv3en10had","tag_id":"clo3w9isd000r8kvv3w66egmu","_id":"clo3w9ise000t8kvv3f1a6de0"},{"post_id":"clo4h74z20000c0vvdh5egppu","tag_id":"clo4h74zc0003c0vv7f64aj7y","_id":"clo4h74ze0006c0vvb2nf8mf2"},{"post_id":"clo4h74z20000c0vvdh5egppu","tag_id":"clo4h74zd0004c0vv4l2he7te","_id":"clo4h74ze0007c0vv4gom3sp9"},{"post_id":"clo4h74z80001c0vvhc3z3b95","tag_id":"clo4hcg930001g4vv92608ue1","_id":"clo4hcg950004g4vvgfvk5aty"},{"post_id":"clo4h74z80001c0vvhc3z3b95","tag_id":"clo4hcg940002g4vv6xtd5k4u","_id":"clo4hcg950005g4vv4sel9z2a"},{"post_id":"clod3x3d20000q4vv0w6g3v7t","tag_id":"clod407i20002q4vv4wz3gu34","_id":"clod407i30006q4vv7sp8ed48"},{"post_id":"clod3x3d20000q4vv0w6g3v7t","tag_id":"clod407i20003q4vv2xjj8qy1","_id":"clod407i30007q4vv468f2ywn"},{"post_id":"clod3x3d20000q4vv0w6g3v7t","tag_id":"clod407i30005q4vvccpkhhxl","_id":"clod407i40008q4vv9rqqaq9u"},{"post_id":"clodwlx5v0000a4vv8hczazi8","tag_id":"clodrw1ri0002y4vvaqal5xjb","_id":"clodwlx5w0001a4vv7lrf7rvk"},{"post_id":"clodwlx5v0000a4vv8hczazi8","tag_id":"clodrw1rj0003y4vve4owbvrh","_id":"clodwlx5w0002a4vvbo5afg5l"},{"post_id":"clody83bn0000kkvv1r8rh74z","tag_id":"clodrw1ri0002y4vvaqal5xjb","_id":"clody83bp0001kkvva4di97aj"},{"post_id":"clody83bn0000kkvv1r8rh74z","tag_id":"clodrw1rj0003y4vve4owbvrh","_id":"clody83bp0002kkvv6w6x34i4"},{"post_id":"cloe2ngxb0000iovv43lychy7","tag_id":"clodrw1ri0002y4vvaqal5xjb","_id":"cloe2ngxg0001iovv4smugogx"},{"post_id":"cloe2ngxb0000iovv43lychy7","tag_id":"clodrw1rj0003y4vve4owbvrh","_id":"cloe2ngxg0002iovvdnszhhio"},{"post_id":"cloe2ngxk0004iovv8cxxf0h3","tag_id":"clodrw1ri0002y4vvaqal5xjb","_id":"cloe2ngxn0005iovv364w1lfw"},{"post_id":"cloe2ngxk0004iovv8cxxf0h3","tag_id":"clodrw1rj0003y4vve4owbvrh","_id":"cloe2ngxn0006iovv5tbcaabh"},{"post_id":"cloe2ngxb0000iovv43lychy7","tag_id":"cloe3yeh40000sgvvgvp6hdm2","_id":"cloe3yeh60002sgvv8t760cnx"},{"post_id":"cloe2ngxb0000iovv43lychy7","tag_id":"cloe3yeh50001sgvvblqigznq","_id":"cloe3yeh60003sgvv8az439hb"},{"post_id":"cloeibslq00007svv0vqh75bg","tag_id":"clodrw1ri0002y4vvaqal5xjb","_id":"cloeibsm000037svv6gh2fepi"},{"post_id":"cloeibslq00007svv0vqh75bg","tag_id":"clodrw1rj0003y4vve4owbvrh","_id":"cloeibsm000047svvh46b30xf"},{"post_id":"cloeibslq00007svv0vqh75bg","tag_id":"cloeibslw00017svveqiq8eds","_id":"cloeibsm100057svv6sc2bozs"},{"post_id":"clofr9l8w0000mcvv5u6rbhg9","tag_id":"clodrw1ri0002y4vvaqal5xjb","_id":"clofr9l950004mcvvfdsthqr3"},{"post_id":"clofr9l8w0000mcvv5u6rbhg9","tag_id":"clodrw1rj0003y4vve4owbvrh","_id":"clofr9l950005mcvv307wfwga"},{"post_id":"clofr9l8w0000mcvv5u6rbhg9","tag_id":"clofr9l910001mcvv4pga5qla","_id":"clofr9l950006mcvv3mbd7ywu"},{"post_id":"clofr9l8w0000mcvv5u6rbhg9","tag_id":"clofr9l950003mcvv4f3l623i","_id":"clofr9l950007mcvveigy4zbe"}],"Tag":[{"name":"心情","_id":"clo3w9is500058kvv10ry33sg"},{"name":"Markdown","_id":"clo3w9isa000b8kvv0qqa4hyh"},{"name":"介绍","_id":"clo3w9isb000f8kvvey682k93"},{"name":"OLED屏幕","_id":"clo3w9isc000i8kvv89xlc67z"},{"name":"LCD屏幕","_id":"clo3w9isc000m8kvvdf6t6c2h"},{"name":"tcp/ip","_id":"clo3w9isd000o8kvvfi655j36"},{"name":"http/https","_id":"clo3w9isd000r8kvv3w66egmu"},{"name":"M4内核","_id":"clo4h74zc0003c0vv7f64aj7y"},{"name":"stm32","_id":"clo4h74zd0004c0vv4l2he7te"},{"name":"图床搭建","_id":"clo4hcg930001g4vv92608ue1"},{"name":"云存储","_id":"clo4hcg940002g4vv6xtd5k4u"},{"name":"mqtt","_id":"clod407i20002q4vv4wz3gu34"},{"name":"主题和负载","_id":"clod407i20003q4vv2xjj8qy1"},{"name":"发布和订阅","_id":"clod407i30005q4vvccpkhhxl"},{"name":"git","_id":"clodrw1ri0002y4vvaqal5xjb"},{"name":"分布式管理系统","_id":"clodrw1rj0003y4vve4owbvrh"},{"name":"工作区","_id":"cloe3yeh40000sgvvgvp6hdm2"},{"name":"暂存区","_id":"cloe3yeh50001sgvvblqigznq"},{"name":"管理修改","_id":"cloeibslw00017svveqiq8eds"},{"name":"撤销修改","_id":"clofr9l910001mcvv4pga5qla"},{"name":"删除","_id":"clofr9l950003mcvv4f3l623i"}]}}