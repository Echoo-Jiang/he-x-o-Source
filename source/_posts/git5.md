---
title: git入门与进阶（五）
tags:
  - git
  - 分布式管理系统
  - 管理修改
categories: 版本控制系统
date: 2023-10-31 20:52:41
---

Git管理的是修改，而不是文件。

本章主要是做一个简单实验，请读者自己动手，以证明上面这句话。

<!--more-->

实验步骤：

1. 对readme.txt做一个修改.
2. git add readme.txt
3. git status
4. 对readme.txt添加一个修改。
5. git commit -m "git跟踪修改而不是文件"
6. git status再次查看状态

做完上面的步骤后，你一定会提出一个疑问：

咦，我~~黑切呢~~的第二次改动呢？

怎么只有第一次的改动被提交？

别激动，我们回顾一下操作过程：

第一次修改 -> `git add` -> 第二次修改 -> `git commit`

提交后，用`git diff HEAD -- readme.txt`命令可以查看工作区和版本库里面最新版本的区别。

>`git diff HEAD -- readme.txt` 是一个查看“工作区”与“HEAD”指向的最新提交（commit）即仓库的最新分支之间差异的命令。如果您移除`HEAD`，命令会变成 `git diff -- readme.txt`，这将比较“工作区”和“暂存区”（Index）的差异，而不是与最新提交的差异。

执行完后，你会发现第二次修改确实没有被提交。



因为Git管理的是修改，当你用`git add`命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，`git commit`只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。

聪明的你，此时应该已经想到怎么解决了。



没错，你可以继续`git add`再`git commit`，也可以别着急提交第一次修改，先`git add`第二次修改，再`git commit`，就相当于把两次修改合并后一块提交了
